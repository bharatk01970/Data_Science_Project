def expand_combined_keys(self, field_expansions, combine_info):
    import itertools
    new_col = combine_info['new_col']
    keys = combine_info['keys']
    char_limits = combine_info['char_limits']

    # Apply truncation for each key independently (before product)
    truncated_lists = []
    for key in keys:
        vals = field_expansions.get(key, [""])
        limit = char_limits.get(key, '*')
        if limit != '*':
            try:
                limit_int = int(limit)
                vals = [v[:limit_int] if v else "" for v in vals]
            except:
                pass
        truncated_lists.append(vals)
    
    # Generate cartesian product to get combined pairs/triples etc
    product_tuples = list(itertools.product(*truncated_lists))

    # The new combined column will have each element of the tuples in sequence, depending on keys order
    combined_values = []
    for tup in product_tuples:
        # Append values in order, each as separate row
        combined_values.extend(tup)

    return new_col, combined_values





def process_single_row(self, row, result_rows):
    import itertools
    
    field_expansions = {}

    # Expand non-dictionary fields with splitting and unique filtering
    for field in self.selected_fields:
        if field not in self.dictionary_fields:
            try:
                field_value = row[field]
            except (KeyError, TypeError):
                field_value = ""
            values = self.split_multi_values(field_value)
            unique_values = []
            for val in values:
                if val and val not in unique_values:
                    unique_values.append(val)
            if not unique_values:
                unique_values = [""]
            field_expansions[field] = unique_values

    # Expand dictionary fields keys similarly
    for field in self.dictionary_fields:
        if field in self.selected_keys:
            try:
                dict_value = row[field]
            except (KeyError, TypeError):
                dict_value = ""
            parsed_dict = self.parse_dictionary_value(dict_value)
            for key in self.selected_keys[field]:
                if key in parsed_dict:
                    all_key_values = []
                    for val in parsed_dict[key]:
                        if val is None:
                            val = ""
                        split_values = self.split_multi_values(val)
                        all_key_values.extend(split_values)
                    unique_values = []
                    for val in all_key_values:
                        if val and val not in unique_values:
                            unique_values.append(val)
                    if not unique_values:
                        unique_values = [""]
                    field_expansions[f"{field}_{key}"] = unique_values
                else:
                    field_expansions[f"{field}_{key}"] = [""]

    # Handle combined keys according to keys order: cartesian product expanded vertically
    if hasattr(self, 'combined_key_info') and self.combined_key_info:
        for field, combine_info in self.combined_key_info.items():
            new_col, combined_values = self.expand_combined_keys(field_expansions, combine_info)
            # Remove individual keys involved in this combination
            for key in combine_info['keys']:
                field_expansions.pop(key, None)
            # Add combined values as new column
            field_expansions[new_col] = combined_values

    # Determine length of combined column (if any), else maximum length of expansions
    combined_col_name = None
    combined_len = 1
    if hasattr(self, 'combined_key_info') and self.combined_key_info:
        # There might be multiple combined columns, sum lengths conservatively take max
        combined_col_name = list(self.combined_key_info.values())[0]['new_col']
        combined_len = len(field_expansions.get(combined_col_name, [""]))
    else:
        combined_len = max(len(v) for v in field_expansions.values()) if field_expansions else 1

    # Align all columns to combined_len by repeating their values
    aligned_expansions = {}
    for k, v in field_expansions.items():
        if len(v) == combined_len:
            aligned_expansions[k] = v
        else:
            repeats = (combined_len // len(v)) + 1
            extended = (v * repeats)[:combined_len]
            aligned_expansions[k] = extended

    # Generate final rows by zipping all aligned expansions
    for i in range(combined_len):
        new_row = {k: aligned_expansions[k][i] for k in aligned_expansions}
        result_rows.append(new_row)