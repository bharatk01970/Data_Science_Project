# Import tkinter for GUI framework - provides window management and user interface components
import tkinter as tk
# Import ttk for themed tkinter widgets - provides modern styled GUI elements
from tkinter import ttk, filedialog, messagebox, simpledialog
# Import pandas for data manipulation - handles CSV/Excel file reading and DataFrame operations
import pandas as pd
# Import json for JSON parsing - attempts to parse dictionary-like strings as JSON objects
import json
# Import ast for abstract syntax tree evaluation - safely evaluates Python literal expressions
import ast
# Import os for operating system interface - handles file path operations and system interactions
import os
# Import typing for type hints - provides static type checking support
from typing import Dict, List, Any, Optional
# Import chardet for automatic encoding detection
import chardet
# Import copy for deep copying data structures
import copy
# Import collections for grouping operations
from collections import defaultdict
# Import itertools for Cartesian product operations
import itertools

# Define the main GUI application class that encapsulates all CSV processing functionality
class CSVProcessorGUI:
    # Constructor method that initializes the GUI application and sets up initial state
    def __init__(self, root):
        # Store reference to the main tkinter root window for later use
        self.root = root
        # Set the window title that appears in the title bar
        self.root.title("CSV Dictionary Field Processor - Enhanced Dynamic Mapping")
        # Set the initial window size (width x height in pixels)
        self.root.geometry("850x700")
        
        # Initialize empty string to store the path of the selected input file
        self.input_file_path = ""
        # Initialize empty dictionary to store mapping between field names and their mapping file paths
        self.mapping_files = {}
        # Initialize None to store the loaded pandas DataFrame containing the input data
        self.df = None
        # Initialize empty list to store field names selected by the user for processing
        self.selected_fields = []
        # Initialize empty dictionary to store fields identified as containing dictionary-like data
        self.dictionary_fields = {}
        # Initialize empty dictionary to store user-selected keys for each dictionary field
        self.selected_keys = {}
        # Initialize empty dictionary to store loaded mapping data as DataFrames
        self.mapping_data = {}
        # Initialize None to store stage 1 processed data before mapping
        self.stage1_data = None
        # Initialize flag to track if stage 1 processing is complete
        self.stage1_complete = False
        # Initialize dictionary to store checkbox variables for field selection
        self.field_checkboxes = {}
        
        # NEW: Store the current working dataframe (updated after each mapping)
        self.current_working_data = None
        # NEW: List to track mapping operations in sequence
        self.mapping_sequence = []
        # NEW: Store row addition mappings
        self.row_addition_mappings = []
        # NEW: Store processed data after each step
        self.processed_data = None
        
        # Call the UI setup method to create and arrange all GUI components
        self.setup_ui()
    
    # Method to create and configure all GUI elements and their layout
    def setup_ui(self):
        # Create the main container frame with padding for visual spacing
        main_frame = ttk.Frame(self.root, padding="10")
        # Place the main frame in the root window using grid layout manager
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure the root window's first column to expand horizontally when window resizes
        self.root.columnconfigure(0, weight=1)
        # Configure the root window's first row to expand vertically when window resizes
        self.root.rowconfigure(0, weight=1)
        # Configure the main frame's second column to expand horizontally
        main_frame.columnconfigure(1, weight=1)
        
        # Create section header label for file loading with bold font
        ttk.Label(main_frame, text="1. Load Input File:", font=('TkDefaultFont', 10, 'bold')).grid(
            row=0, column=0, columnspan=2, sticky=tk.W, pady=(0, 5))
        
        # Create button to trigger file selection dialog
        ttk.Button(main_frame, text="Select Input File", 
                  command=self.load_input_file).grid(row=1, column=0, sticky=tk.W, pady=(0, 10))
        
        # Create label to display the name of the selected input file
        self.input_file_label = ttk.Label(main_frame, text="No file selected")
        self.input_file_label.grid(row=1, column=1, sticky=tk.W, padx=(10, 0), pady=(0, 10))
        
        # Create section header label for field selection
        ttk.Label(main_frame, text="2. Select Fields for Processing:", 
                 font=('TkDefaultFont', 10, 'bold')).grid(
            row=2, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        # Create container frame for field selection controls
        field_frame = ttk.Frame(main_frame)
        field_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        field_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(3, weight=1)
        
        # Create canvas with scrollbar for checkboxes
        field_canvas = tk.Canvas(field_frame, height=120, highlightthickness=0)
        field_scrollbar = ttk.Scrollbar(field_frame, orient="vertical", command=field_canvas.yview)
        self.field_checkbox_frame = ttk.Frame(field_canvas)
        
        self.field_checkbox_frame.bind(
            "<Configure>",
            lambda e: field_canvas.configure(scrollregion=field_canvas.bbox("all"))
        )
        
        field_canvas.create_window((0, 0), window=self.field_checkbox_frame, anchor="nw")
        field_canvas.configure(yscrollcommand=field_scrollbar.set)
        
        field_canvas.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        field_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        field_frame.rowconfigure(0, weight=1)
        
        # Enable mouse wheel scrolling for field canvas
        def on_field_mousewheel(event):
            field_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        field_canvas.bind_all("<MouseWheel>", on_field_mousewheel)
        
        # Create section header label for stage 1 processing
        ttk.Label(main_frame, text="3. Stage 1 Processing:", 
                 font=('TkDefaultFont', 10, 'bold')).grid(
            row=4, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        # Create button for stage 1 processing
        self.stage1_button = ttk.Button(main_frame, text="Process Stage 1 (Dictionary Expansion)", 
                  command=self.process_stage1, state='disabled')
        self.stage1_button.grid(row=5, column=0, sticky=tk.W, pady=(0, 10))
        
        # Create label to show stage 1 status
        self.stage1_status_label = ttk.Label(main_frame, text="")
        self.stage1_status_label.grid(row=5, column=1, sticky=tk.W, padx=(10, 0), pady=(0, 10))
        
        # NEW: Create section for dynamic mapping management
        ttk.Label(main_frame, text="4. Dynamic Mapping Management:", 
                 font=('TkDefaultFont', 10, 'bold')).grid(
            row=6, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        # Create sub-frame container for mapping operations
        mapping_frame = ttk.Frame(main_frame)
        mapping_frame.grid(row=7, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # NEW: Buttons for different mapping operations
        button_row1 = ttk.Frame(mapping_frame)
        button_row1.grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(0, 5))
        
        self.add_column_mapping_button = ttk.Button(button_row1, text="Add Column Mapping", 
                  command=self.add_column_mapping_file, state='disabled')
        self.add_column_mapping_button.pack(side=tk.LEFT, padx=(0, 5))
        
        self.add_row_mapping_button = ttk.Button(button_row1, text="Add Row Mapping", 
                  command=self.add_row_mapping_file, state='disabled')
        self.add_row_mapping_button.pack(side=tk.LEFT, padx=(0, 5))
        
        self.clear_mappings_button = ttk.Button(button_row1, text="Clear All Mappings", 
                  command=self.clear_all_mappings, state='disabled')
        self.clear_mappings_button.pack(side=tk.LEFT, padx=(0, 5))
        
        # Create listbox to display mapping sequence
        mapping_label = ttk.Label(mapping_frame, text="Mapping Sequence:")
        mapping_label.grid(row=1, column=0, sticky=tk.W, pady=(5, 2))
        
        self.mapping_listbox = tk.Listbox(mapping_frame, height=4)
        self.mapping_listbox.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 5))
        mapping_frame.columnconfigure(0, weight=1)
        
        # Current columns display
        self.current_columns_label = ttk.Label(mapping_frame, text="Current columns: None", 
                                               font=('TkDefaultFont', 8), foreground='blue')
        self.current_columns_label.grid(row=3, column=0, columnspan=2, sticky=tk.W)
        
        # Create stage 2 process button with accent styling
        self.stage2_button = ttk.Button(main_frame, text="Process Stage 2 (Final Output)", 
                  command=self.process_stage2, style='Accent.TButton', state='disabled')
        self.stage2_button.grid(row=8, column=0, columnspan=2, pady=10)
        
        # Create export button initially disabled until data is processed
        self.export_button = ttk.Button(main_frame, text="Export Results", 
                                       command=self.export_data, state='disabled')
        self.export_button.grid(row=9, column=0, columnspan=2, pady=5)
        
        # Create StringVar to hold status messages for dynamic updates
        self.status_var = tk.StringVar(value="Ready to load file...")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, 
                              relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=10, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
    
    # NEW METHOD: Clear all mappings
    def clear_all_mappings(self):
        """Clear all mapping operations and reset to stage 1 data"""
        response = messagebox.askyesno("Clear Mappings", 
            "Are you sure you want to clear all mapping operations?\n"
            "This will reset to Stage 1 processed data.")
        
        if response:
            self.mapping_files.clear()
            self.mapping_data.clear()
            self.mapping_sequence.clear()
            self.row_addition_mappings.clear()
            self.mapping_listbox.delete(0, tk.END)
            self.current_working_data = copy.deepcopy(self.stage1_data)
            self.update_current_columns_display()
            self.status_var.set("All mappings cleared. Reset to Stage 1 data.")
    
    # NEW METHOD: Add column mapping file (Feature A)
    def add_column_mapping_file(self):
        """Add a mapping file to add new columns to the current working data"""
        if not self.stage1_complete or not self.current_working_data:
            messagebox.showwarning("Warning", "Please complete Stage 1 processing first")
            return
        
        file_path = filedialog.askopenfilename(
            title="Select Column Mapping File",
            filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                encoding = self.detect_encoding(file_path)
                
                if file_path.endswith('.csv'):
                    mapping_df = pd.read_csv(file_path, encoding=encoding)
                else:
                    mapping_df = pd.read_csv(file_path, delimiter='\t', encoding=encoding)
                
                # Get current column names
                current_columns = set()
                for row in self.current_working_data:
                    current_columns.update(row.keys())
                
                mapping_columns = set(mapping_df.columns)
                common_fields = current_columns.intersection(mapping_columns)
                
                if not common_fields:
                    messagebox.showwarning("Warning", 
                        f"No matching columns found.\n"
                        f"Current columns: {sorted(list(current_columns))}\n"
                        f"Mapping columns: {sorted(list(mapping_columns))}")
                    return
                
                # Select key column
                field_to_map = list(common_fields)[0]
                
                if len(common_fields) > 1:
                    field_to_map = simpledialog.askstring(
                        "Multiple Matches Found",
                        f"Multiple matching columns found: {list(common_fields)}\n"
                        f"Enter the key column name for mapping:",
                        initialvalue=field_to_map
                    )
                    
                    if not field_to_map or field_to_map not in common_fields:
                        messagebox.showwarning("Warning", "Invalid field selection")
                        return
                
                # Apply the mapping immediately to current working data
                new_columns = [col for col in mapping_df.columns if col != field_to_map]
                
                # Create mapping dictionary for each new column
                for new_col in new_columns:
                    mapping_dict = dict(zip(mapping_df[field_to_map].astype(str), 
                                           mapping_df[new_col]))
                    
                    # Add new column to each row
                    for row in self.current_working_data:
                        key_value = str(row.get(field_to_map, ""))
                        row[new_col] = mapping_dict.get(key_value, "")
                
                # Store the mapping operation
                self.mapping_sequence.append({
                    'type': 'column_mapping',
                    'key_field': field_to_map,
                    'file': os.path.basename(file_path),
                    'new_columns': new_columns
                })
                
                self.mapping_listbox.insert(tk.END, 
                    f"[Column] {field_to_map} → {', '.join(new_columns)} ({os.path.basename(file_path)})")
                
                self.update_current_columns_display()
                self.status_var.set(f"Column mapping applied: Added {len(new_columns)} column(s)")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load mapping file: {str(e)}")
    
    # NEW METHOD: Add row mapping file (Feature B & C)
    def add_row_mapping_file(self):
        """Add a mapping file to add rows based on mapping logic"""
        if not self.stage1_complete or not self.current_working_data:
            messagebox.showwarning("Warning", "Please complete Stage 1 processing first")
            return
        
        file_path = filedialog.askopenfilename(
            title="Select Row Addition Mapping File",
            filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                encoding = self.detect_encoding(file_path)
                
                if file_path.endswith('.csv'):
                    mapping_df = pd.read_csv(file_path, encoding=encoding)
                else:
                    mapping_df = pd.read_csv(file_path, delimiter='\t', encoding=encoding)
                
                # Show configuration dialog
                config = self.show_row_mapping_config(mapping_df)
                
                if not config:
                    return
                
                # Apply row addition mapping
                self.apply_row_addition_mapping(mapping_df, config)
                
                # Store the mapping operation
                self.mapping_sequence.append({
                    'type': 'row_mapping',
                    'file': os.path.basename(file_path),
                    'config': config
                })
                
                self.mapping_listbox.insert(tk.END, 
                    f"[Row] {config['source_col']} → {config['new_col']} ({os.path.basename(file_path)})")
                
                self.update_current_columns_display()
                self.status_var.set(f"Row mapping applied from {os.path.basename(file_path)}")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to apply row mapping: {str(e)}")
    
    # NEW METHOD: Show row mapping configuration dialog
    def show_row_mapping_config(self, mapping_df):
        """Show dialog to configure row addition mapping"""
        popup = tk.Toplevel(self.root)
        popup.title("Configure Row Addition Mapping")
        popup.geometry("550x450")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Configure Row Addition Mapping", 
                 font=('TkDefaultFont', 11, 'bold')).pack(pady=10)
        
        # Get current columns
        current_columns = set()
        for row in self.current_working_data:
            current_columns.update(row.keys())
        
        config_frame = ttk.Frame(popup)
        config_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Source column (from mapping file)
        ttk.Label(config_frame, text="Source Column (from mapping file):").grid(
            row=0, column=0, sticky=tk.W, pady=5)
        source_var = tk.StringVar()
        source_combo = ttk.Combobox(config_frame, textvariable=source_var, width=30, state='readonly')
        source_combo['values'] = list(mapping_df.columns)
        if len(mapping_df.columns) > 0:
            source_combo.current(0)
        source_combo.grid(row=0, column=1, pady=5, padx=(5, 0))
        
        # Target column (from mapping file)
        ttk.Label(config_frame, text="Target Column (from mapping file):").grid(
            row=1, column=0, sticky=tk.W, pady=5)
        target_var = tk.StringVar()
        target_combo = ttk.Combobox(config_frame, textvariable=target_var, width=30, state='readonly')
        target_combo['values'] = list(mapping_df.columns)
        if len(mapping_df.columns) > 1:
            target_combo.current(1)
        target_combo.grid(row=1, column=1, pady=5, padx=(5, 0))
        
        # Match column (existing column to match against)
        ttk.Label(config_frame, text="Match Column (existing data):").grid(
            row=2, column=0, sticky=tk.W, pady=5)
        match_var = tk.StringVar()
        match_combo = ttk.Combobox(config_frame, textvariable=match_var, width=30, state='readonly')
        match_combo['values'] = sorted(list(current_columns))
        if len(current_columns) > 0:
            match_combo.current(0)
        match_combo.grid(row=2, column=1, pady=5, padx=(5, 0))
        
        # Group column (column to group by for row additions)
        ttk.Label(config_frame, text="Group By Column (for row additions):").grid(
            row=3, column=0, sticky=tk.W, pady=5)
        group_var = tk.StringVar()
        group_combo = ttk.Combobox(config_frame, textvariable=group_var, width=30, state='readonly')
        group_combo['values'] = [''] + sorted(list(current_columns))
        group_combo.current(0)
        group_combo.grid(row=3, column=1, pady=5, padx=(5, 0))
        
        # Blank on match option
        blank_on_match_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(config_frame, text="Leave target column blank when match occurs", 
                       variable=blank_on_match_var).grid(
            row=4, column=0, columnspan=2, sticky=tk.W, pady=10)
        
        # Info text
        info_text = tk.Text(config_frame, height=8, width=60, wrap=tk.WORD)
        info_text.grid(row=5, column=0, columnspan=2, pady=10)
        info_text.insert(tk.END, 
            "How Row Addition Works:\n\n"
            "1. Source Column: Value from mapping file to match against existing data\n"
            "2. Target Column: New column to add with mapped values\n"
            "3. Match Column: Existing column to compare with source values\n"
            "4. Group By Column: If specified, adds one row per unique value in this column\n"
            "5. Blank on Match: If checked, leaves target blank where match column = source value")
        info_text.config(state='disabled')
        
        result = {}
        
        def confirm():
            source_col = source_var.get()
            target_col = target_var.get()
            match_col = match_var.get()
            group_col = group_var.get()
            
            if not source_col or not target_col or not match_col:
                messagebox.showwarning("Warning", "Please fill all required fields")
                return
            
            if source_col == target_col:
                messagebox.showwarning("Warning", "Source and target columns must be different")
                return
            
            result['source_col'] = source_col
            result['new_col'] = target_col
            result['match_col'] = match_col
            result['group_col'] = group_col if group_col else None
            result['blank_on_match'] = blank_on_match_var.get()
            popup.destroy()
        
        def cancel():
            popup.destroy()
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=10)
        ttk.Button(button_frame, text="Confirm", command=confirm).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        return result if result else None
    
    # NEW METHOD: Apply row addition mapping
    def apply_row_addition_mapping(self, mapping_df, config):
        """Apply row addition mapping to current working data"""
        source_col = config['source_col']
        new_col = config['new_col']
        match_col = config['match_col']
        group_col = config['group_col']
        blank_on_match = config['blank_on_match']
        
        # Create mapping dictionary
        mapping_dict = dict(zip(mapping_df[source_col].astype(str), 
                               mapping_df[new_col]))
        
        new_rows = []
        
        if group_col:
            # Group-based row addition (Feature B)
            grouped_data = defaultdict(list)
            
            for row in self.current_working_data:
                group_value = row.get(group_col, "")
                grouped_data[group_value].append(row)
            
            # For each group, add mapped rows
            for group_value, group_rows in grouped_data.items():
                # Add original rows
                for row in group_rows:
                    new_row = copy.deepcopy(row)
                    match_value = str(row.get(match_col, ""))
                    if match_value in mapping_dict:
                        if blank_on_match and match_value == row.get(match_col, ""):
                            new_row[new_col] = ""
                        else:
                            new_row[new_col] = mapping_dict[match_value]
                    else:
                        new_row[new_col] = ""
                    new_rows.append(new_row)
                
                # Add new rows for each mapping entry
                for map_source, map_target in mapping_dict.items():
                    exists = any(str(row.get(match_col, "")) == map_source for row in group_rows)
                    
                    if not exists and group_rows:
                        base_row = group_rows[0]
                        new_row = copy.deepcopy(base_row)
                        new_row[match_col] = map_source
                        new_row[new_col] = "" if blank_on_match else map_target
                        new_rows.append(new_row)
        else:
            # Simple row addition without grouping
            for row in self.current_working_data:
                new_row = copy.deepcopy(row)
                match_value = str(row.get(match_col, ""))
                
                if match_value in mapping_dict:
                    if blank_on_match:
                        new_row[new_col] = ""
                    else:
                        new_row[new_col] = mapping_dict[match_value]
                else:
                    new_row[new_col] = ""
                
                new_rows.append(new_row)
            
            # Add new rows for unmapped values
            existing_values = {str(row.get(match_col, "")) for row in self.current_working_data}
            for map_source, map_target in mapping_dict.items():
                if map_source not in existing_values and self.current_working_data:
                    new_row = copy.deepcopy(self.current_working_data[0])
                    for key in new_row.keys():
                        new_row[key] = ""
                    new_row[match_col] = map_source
                    new_row[new_col] = map_target
                    new_rows.append(new_row)
        
        self.current_working_data = new_rows
    
    # NEW METHOD: Update current columns display
    def update_current_columns_display(self):
        """Update the display showing current columns"""
        if self.current_working_data:
            current_columns = set()
            for row in self.current_working_data:
                current_columns.update(row.keys())
            
            col_list = sorted(list(current_columns))
            col_text = ', '.join(col_list[:10])
            if len(col_list) > 10:
                col_text += f"... ({len(col_list)} total)"
            
            self.current_columns_label.config(
                text=f"Current columns ({len(col_list)}): {col_text}")
        else:
            self.current_columns_label.config(text="Current columns: None")
    
    # Method to get sample values from a column
    def get_sample_values(self, column_name, max_samples=2):
        """Get up to max_samples non-null unique sample values from a column"""
        try:
            samples = self.df[column_name].dropna().unique()[:max_samples]
            sample_strs = []
            for s in samples:
                s_str = str(s)
                if len(s_str) > 30:
                    s_str = s_str[:27] + "..."
                sample_strs.append(s_str)
            return sample_strs
        except:
            return []
    
    # Method to populate field checkboxes with sample values
    def populate_field_checkboxes(self):
        """Populate the field selection area with checkboxes and sample values"""
        for widget in self.field_checkbox_frame.winfo_children():
            widget.destroy()
        self.field_checkboxes.clear()
        
        button_frame = ttk.Frame(self.field_checkbox_frame)
        button_frame.grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(0, 5))
        
        def select_all():
            for var in self.field_checkboxes.values():
                var.set(True)
        
        def deselect_all():
            for var in self.field_checkboxes.values():
                var.set(False)
        
        ttk.Button(button_frame, text="Select All", command=select_all, width=12).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="Deselect All", command=deselect_all, width=12).pack(side=tk.LEFT, padx=2)
        
        for idx, col in enumerate(self.df.columns, start=1):
            var = tk.BooleanVar(value=False)
            self.field_checkboxes[col] = var
            
            samples = self.get_sample_values(col)
            sample_text = f" (e.g., {', '.join(samples)})" if samples else ""
            
            cb = ttk.Checkbutton(
                self.field_checkbox_frame, 
                text=f"{col}{sample_text}",
                variable=var
            )
            cb.grid(row=idx, column=0, sticky=tk.W, padx=5, pady=2)
    
    # Method to detect file encoding automatically
    def detect_encoding(self, file_path):
        """Detect the encoding of a file"""
        try:
            with open(file_path, 'rb') as f:
                raw_data = f.read(100000)
                result = chardet.detect(raw_data)
                encoding = result['encoding']
                return encoding if encoding else 'utf-8'
        except Exception:
            return 'utf-8'
    
    # Method to handle input file selection and loading
    def load_input_file(self):
        file_path = filedialog.askopenfilename(
            title="Select Input File",
            filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                encoding = self.detect_encoding(file_path)
                
                if file_path.endswith('.csv'):
                    self.df = pd.read_csv(file_path, encoding=encoding)
                else:
                    self.df = pd.read_csv(file_path, delimiter='\t', encoding=encoding)
                
                self.input_file_path = file_path
                self.input_file_label.config(text=os.path.basename(file_path))
                
                self.populate_field_checkboxes()
                
                self.status_var.set(f"Loaded file with {len(self.df)} rows and {len(self.df.columns)} columns (encoding: {encoding})")
                
                # Enable field selection and stage 1 button
                self.stage1_button.config(state='normal')
                self.stage1_complete = False
                self.stage1_status_label.config(text="")
                self.add_column_mapping_button.config(state='disabled')
                self.add_row_mapping_button.config(state='disabled')
                self.clear_mappings_button.config(state='disabled')
                self.stage2_button.config(state='disabled')
                self.export_button.config(state='disabled')
                
                # Clear mapping data
                self.mapping_files.clear()
                self.mapping_data.clear()
                self.mapping_sequence.clear()
                self.row_addition_mappings.clear()
                self.mapping_listbox.delete(0, tk.END)
                self.current_working_data = None
                self.update_current_columns_display()
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load file: {str(e)}")
                self.status_var.set("Error loading file")
    
    # Method to show selected columns popup
    def show_selected_columns_popup(self, columns):
        """Show popup displaying selected columns after Stage 1"""
        popup = tk.Toplevel(self.root)
        popup.title("Stage 1 - Selected Columns")
        popup.geometry("500x400")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Stage 1 Processing Complete!", 
                 font=('TkDefaultFont', 12, 'bold')).pack(pady=10)
        
        ttk.Label(popup, text=f"Total columns in output: {len(columns)}", 
                 font=('TkDefaultFont', 10)).pack(pady=5)
        
        list_frame = ttk.Frame(popup)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        listbox = tk.Listbox(list_frame)
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=listbox.yview)
        listbox.configure(yscrollcommand=scrollbar.set)
        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        for col in sorted(columns):
            listbox.insert(tk.END, col)
        
        ttk.Button(popup, text="OK", command=popup.destroy).pack(pady=10)
        
        popup.wait_window()
    
    # Method to perform stage 1 processing - dictionary expansion
    def process_stage1(self):
        if self.df is None:
            messagebox.showwarning("Warning", "Please load an input file first")
            return
        
        self.selected_fields = [col for col, var in self.field_checkboxes.items() if var.get()]
        
        if not self.selected_fields:
            messagebox.showwarning("Warning", "Please select at least one field")
            return
        
        try:
            self.dictionary_fields = self.detect_dictionary_fields(self.selected_fields)
            
            self.selected_keys = {}
            
            if self.dictionary_fields:
                for field, available_keys in self.dictionary_fields.items():
                    if available_keys:
                        selected = self.show_key_selection_popup(field, available_keys)
                        if selected:
                            self.selected_keys[field] = selected
                        else:
                            response = messagebox.askyesno("Skip Field?", 
                                f"No keys selected for field '{field}'.\n\n"
                                f"Do you want to keep this field without dictionary expansion?")
                            if not response:
                                self.selected_fields.remove(field)
            
            self.stage1_data = self.process_stage1_dataframe()
            
            if self.stage1_data:
                stage1_columns = set()
                for row in self.stage1_data:
                    stage1_columns.update(row.keys())
                
                self.selected_fields = list(stage1_columns)
                
                self.show_selected_columns_popup(stage1_columns)
            
            # Mark stage 1 as complete
            self.stage1_complete = True
            self.stage1_status_label.config(text=f"✓ Complete ({len(self.stage1_data)} rows)")
            
            # NEW: Initialize current working data with stage 1 results
            self.current_working_data = copy.deepcopy(self.stage1_data)
            
            # Enable mapping file addition and stage 2 processing
            self.add_column_mapping_button.config(state='normal')
            self.add_row_mapping_button.config(state='normal')
            self.clear_mappings_button.config(state='normal')
            self.stage2_button.config(state='normal')
            
            # Update columns display
            self.update_current_columns_display()
            
            self.status_var.set(f"Stage 1 complete. {len(self.stage1_data)} rows generated from selected fields. You can now add mappings or proceed to Stage 2.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to process Stage 1: {str(e)}")
            self.status_var.set("Stage 1 processing failed")
    
    # Method to process dataframe for stage 1
    def process_stage1_dataframe(self):
        """Process the dataframe for stage 1 - dictionary expansion and multi-value splitting"""
        result_rows = []
        
        for index, row in self.df.iterrows():
            self.process_single_row(row, result_rows)
        
        return result_rows
    
    # Method to split multi-valued strings
    def split_multi_values(self, value):
        """Split comma or semicolon separated values"""
        if pd.isna(value) or value == "" or value is None:
            return [""]
        
        value_str = str(value).strip()
        
        if not value_str:
            return [""]
        
        if ';' in value_str:
            return [v.strip() for v in value_str.split(';') if v.strip()]
        elif ',' in value_str:
            return [v.strip() for v in value_str.split(',') if v.strip()]
        else:
            return [value_str]
    
    # Method to detect if a value contains dictionary-like data
    def is_dictionary_like(self, value):
        """Check if a value looks like a dictionary"""
        try:
            if pd.isna(value):
                return False
        except (ValueError, TypeError):
            if value is None:
                return False
        
        if value == "":
            return False
        
        value_str = str(value).strip()
        
        if value_str.startswith('{') and value_str.endswith('}'):
            return True
        
        if ':' in value_str or '=' in value_str:
            return True
        
        return False
    
    # Method to parse dictionary-like strings
    def parse_dictionary_value(self, value):
        """Parse dictionary-like value into key-value pairs, handling duplicate keys by collecting all values"""
        try:
            if pd.isna(value):
                return {}
        except (ValueError, TypeError):
            if value is None:
                return {}
        
        if value == "":
            return {}

        value_str = str(value).strip()
        result = {}

        # Try JSON parsing
        try:
            if value_str.startswith('{') and value_str.endswith('}'):
                parsed = json.loads(value_str)
                for k, v in parsed.items():
                    result[k] = [v] if not isinstance(v, list) else v
                return result
        except:
            pass

        # Try literal eval
        try:
            parsed = ast.literal_eval(value_str)
            if isinstance(parsed, dict):
                for k, v in parsed.items():
                    result[k] = [v] if not isinstance(v, list) else v
                return result
        except:
            pass

        # Manual parsing for newline-separated key-value pairs with duplicate key support
        try:
            lines = [line.strip() for line in value_str.split('\n') if line.strip()]

            for line in lines:
                if ':' in line:
                    key, val = line.split(':', 1)
                    key = key.strip()
                    val = val.strip()
                    if key in result:
                        result[key].append(val)
                    else:
                        result[key] = [val]
                elif '=' in line:
                    key, val = line.split('=', 1)
                    key = key.strip()
                    val = val.strip()
                    if key in result:
                        result[key].append(val)
                    else:
                        result[key] = [val]
                else:
                    if line in result:
                        result[line].append("")
                    else:
                        result[line] = [""]

        except Exception:
            pass

        return result
    
    # Method to detect dictionary fields
    def detect_dictionary_fields(self, selected_fields):
        """Detect which fields contain dictionary-like values and collect all unique keys including duplicates"""
        dict_fields = {}
        
        for field in selected_fields:
            if field in self.df.columns:
                sample_values = self.df[field].dropna().head(10)
                
                dict_count = 0
                all_keys = set()
                
                for value in sample_values:
                    if self.is_dictionary_like(value):
                        dict_count += 1
                        parsed = self.parse_dictionary_value(value)
                        all_keys.update(parsed.keys())
                
                if dict_count > len(sample_values) * 0.5:
                    dict_fields[field] = list(all_keys)
        
        return dict_fields
    
    # Method to show key selection popup with checkboxes
    def show_key_selection_popup(self, field, available_keys):
        """Show popup for key selection in dictionary fields with checkboxes"""
        popup = tk.Toplevel(self.root)
        popup.title(f"Select Keys for Field: {field}")
        popup.geometry("450x350")
        popup.transient(self.root)
        popup.grab_set()
        
        header_frame = ttk.Frame(popup)
        header_frame.pack(pady=10, padx=10, fill=tk.X)
        
        ttk.Label(header_frame, text=f"Select keys to include from field '{field}':", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W)
        
        ttk.Label(header_frame, text="Tip: Check the boxes for keys you want to include.", 
                 font=('TkDefaultFont', 8), foreground='gray').pack(anchor=tk.W, pady=(2, 0))
        
        key_frame = ttk.Frame(popup)
        key_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        canvas = tk.Canvas(key_frame, highlightthickness=0)
        scrollbar = ttk.Scrollbar(key_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        key_vars = {}
        for key in available_keys:
            var = tk.BooleanVar(value=False)
            key_vars[key] = var
            cb = ttk.Checkbutton(scrollable_frame, text=key, variable=var)
            cb.pack(anchor=tk.W, padx=5, pady=2)
        
        status_label = ttk.Label(popup, text=f"0 of {len(available_keys)} keys selected", 
                                foreground='blue')
        status_label.pack(pady=(0, 5))
        
        def update_status():
            count = sum(1 for var in key_vars.values() if var.get())
            status_label.config(text=f"{count} of {len(available_keys)} keys selected")
        
        for var in key_vars.values():
            var.trace('w', lambda *args: update_status())
        
        selected_keys = []
        
        def on_select_all():
            for var in key_vars.values():
                var.set(True)
        
        def on_clear_all():
            for var in key_vars.values():
                var.set(False)
        
        def on_confirm():
            nonlocal selected_keys
            selected_keys = [key for key, var in key_vars.items() if var.get()]
            popup.destroy()
        
        def on_cancel():
            nonlocal selected_keys
            selected_keys = []
            popup.destroy()
        
        helper_button_frame = ttk.Frame(popup)
        helper_button_frame.pack(pady=(5, 5))
        
        ttk.Button(helper_button_frame, text="Select All", 
                  command=on_select_all).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(helper_button_frame, text="Clear All", 
                  command=on_clear_all).pack(side=tk.LEFT, padx=5)
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=10)
        
        ttk.Button(button_frame, text="Confirm Selection", 
                  command=on_confirm).pack(side=tk.LEFT, padx=5)
        
        ttk.Button(button_frame, text="Cancel", 
                  command=on_cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        
        return selected_keys
    
    # Method to orchestrate stage 2 processing
    def process_stage2(self):
        """Stage 2: Use current working data (with all mappings applied) as final output"""
        if not self.stage1_complete or not self.current_working_data:
            messagebox.showwarning("Warning", "Please complete Stage 1 processing first")
            return
        
        try:
            self.processed_data = copy.deepcopy(self.current_working_data)
            
            self.export_button.config(state='normal')
            
            num_rows = len(self.processed_data)
            columns = set()
            for row in self.processed_data:
                columns.update(row.keys())
            num_cols = len(columns)
            
            self.status_var.set(f"Stage 2 complete. {num_rows} rows with {num_cols} columns ready for export.")
            
            messagebox.showinfo("Stage 2 Complete", 
                f"Processing complete!\n\n"
                f"Total Rows: {num_rows}\n"
                f"Total Columns: {num_cols}\n"
                f"Mappings Applied: {len(self.mapping_sequence)}\n\n"
                f"Ready to export.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to process Stage 2: {str(e)}")
            self.status_var.set("Stage 2 processing failed")
    
    # Method to process a single row
    def process_single_row(self, row, result_rows):
        """Process a single row, handling multi-values, dictionary fields with duplicate keys, and Cartesian product"""
        field_expansions = {}
        
        for field in self.selected_fields:
            if field not in self.dictionary_fields:
                try:
                    field_value = row[field]
                except (KeyError, TypeError):
                    field_value = ""
                
                values = self.split_multi_values(field_value)
                unique_values = []
                for val in values:
                    if val and val not in unique_values:
                        unique_values.append(val)
                if not unique_values:
                    unique_values = [""]
                field_expansions[field] = unique_values
        
        for field in self.dictionary_fields:
            if field in self.selected_keys:
                try:
                    dict_value = row[field]
                except (KeyError, TypeError):
                    dict_value = ""
                
                parsed_dict = self.parse_dictionary_value(dict_value)
                
                for key in self.selected_keys[field]:
                    if key in parsed_dict:
                        all_key_values = []
                        for val in parsed_dict[key]:
                            if val is None:
                                val = ""
                            split_values = self.split_multi_values(val)
                            all_key_values.extend(split_values)
                        
                        unique_values = []
                        for val in all_key_values:
                            if val and val not in unique_values:
                                unique_values.append(val)
                        if not unique_values:
                            unique_values = [""]
                        field_expansions[f"{field}_{key}"] = unique_values
                    else:
                        field_expansions[f"{field}_{key}"] = [""]
        
        if field_expansions:
            field_names = list(field_expansions.keys())
            field_values = list(field_expansions.values())
            
            for combination in itertools.product(*field_values):
                new_row = {}
                for field_name, value in zip(field_names, combination):
                    new_row[field_name] = value
                
                if new_row not in result_rows:
                    result_rows.append(new_row)
    
    # Method to apply mappings (kept for backwards compatibility)
    def apply_mappings(self, result_rows):
        """Apply mapping files to add additional columns with original column names"""
        for field, mapping_df in self.mapping_data.items():
            if field in self.selected_fields:
                if len(mapping_df.columns) >= 2:
                    key_col = mapping_df.columns[0]
                    value_col = mapping_df.columns[1]
                    
                    mapping_dict = dict(zip(mapping_df[key_col], mapping_df[value_col]))
                    
                    for row in result_rows:
                        if field in row:
                            mapped_value = mapping_dict.get(row[field], "")
                            row[value_col] = mapped_value
        
        return result_rows
    
    # METHOD: Manage default columns - add new and remove existing (with checkboxes)
    def manage_default_columns(self, df):
        """Step A: Add default columns and remove existing columns using checkboxes"""
        popup = tk.Toplevel(self.root)
        popup.title("Manage Default Columns")
        popup.geometry("600x500")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Step A: Add Default Columns & Remove Existing Columns", 
                 font=('TkDefaultFont', 11, 'bold')).pack(pady=10)
        
        notebook = ttk.Notebook(popup)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Tab 1: Add Default Columns
        add_frame = ttk.Frame(notebook)
        notebook.add(add_frame, text="Add Default Columns")
        
        ttk.Label(add_frame, text="Add new columns with default values based on existing columns:", 
                 font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
        
        add_list_frame = ttk.Frame(add_frame)
        add_list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        add_listbox = tk.Listbox(add_list_frame, height=10)
        add_scrollbar = ttk.Scrollbar(add_list_frame, orient="vertical", command=add_listbox.yview)
        add_listbox.configure(yscrollcommand=add_scrollbar.set)
        add_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        add_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        default_columns = []
        
        def add_default_column():
            detail_popup = tk.Toplevel(popup)
            detail_popup.title("Add Default Column")
            detail_popup.geometry("500x400")
            detail_popup.transient(popup)
            detail_popup.grab_set()
            
            ttk.Label(detail_popup, text="New Column Name:").grid(row=0, column=0, sticky=tk.W, padx=10, pady=5)
            new_col_entry = ttk.Entry(detail_popup, width=30)
            new_col_entry.grid(row=0, column=1, padx=10, pady=5)
            
            ttk.Label(detail_popup, text="Source Column:").grid(row=1, column=0, sticky=tk.W, padx=10, pady=5)
            source_var = tk.StringVar()
            source_combo = ttk.Combobox(detail_popup, textvariable=source_var, width=28, state='readonly')
            source_combo['values'] = list(df.columns)
            source_combo.grid(row=1, column=1, padx=10, pady=5)
            
            ttk.Label(detail_popup, text="Value Mapping (format: source_value=default_value, one per line):", 
                     font=('TkDefaultFont', 9)).grid(row=2, column=0, columnspan=2, sticky=tk.W, padx=10, pady=(10, 5))
            
            mapping_text = tk.Text(detail_popup, height=10, width=50)
            mapping_text.grid(row=3, column=0, columnspan=2, padx=10, pady=5)
            
            ttk.Label(detail_popup, text="Example:\nValue1=DefaultA\nValue2=DefaultB\n*=DefaultForAll", 
                     font=('TkDefaultFont', 8), foreground='gray').grid(row=4, column=0, columnspan=2, sticky=tk.W, padx=10)
            
            def save_mapping():
                new_col = new_col_entry.get().strip()
                source_col = source_var.get().strip()
                
                if not new_col:
                    messagebox.showwarning("Warning", "Please enter a new column name")
                    return
                if not source_col:
                    messagebox.showwarning("Warning", "Please select a source column")
                    return
                
                mapping_dict = {}
                mapping_lines = mapping_text.get("1.0", tk.END).strip().split('\n')
                for line in mapping_lines:
                    if '=' in line:
                        key, val = line.split('=', 1)
                        mapping_dict[key.strip()] = val.strip()
                
                if not mapping_dict:
                    messagebox.showwarning("Warning", "Please provide at least one value mapping")
                    return
                
                default_columns.append((new_col, source_col, mapping_dict))
                add_listbox.insert(tk.END, f"{new_col} ← {source_col}")
                detail_popup.destroy()
            
            ttk.Button(detail_popup, text="Save", command=save_mapping).grid(row=5, column=0, columnspan=2, pady=10)
        
        def remove_default_column():
            selection = add_listbox.curselection()
            if selection:
                idx = selection[0]
                add_listbox.delete(idx)
                default_columns.pop(idx)
        
        button_frame1 = ttk.Frame(add_frame)
        button_frame1.pack(pady=5)
        ttk.Button(button_frame1, text="Add Column", command=add_default_column).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame1, text="Remove Selected", command=remove_default_column).pack(side=tk.LEFT, padx=5)
        
        # Tab 2: Remove Columns
        remove_frame = ttk.Frame(notebook)
        notebook.add(remove_frame, text="Remove Columns")
        
        ttk.Label(remove_frame, text="Check columns to remove from final output:", 
                 font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
        
        remove_canvas_frame = ttk.Frame(remove_frame)
        remove_canvas_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        remove_canvas = tk.Canvas(remove_canvas_frame, highlightthickness=0)
        remove_scrollbar = ttk.Scrollbar(remove_canvas_frame, orient="vertical", command=remove_canvas.yview)
        remove_scrollable = ttk.Frame(remove_canvas)
        
        remove_scrollable.bind(
            "<Configure>",
            lambda e: remove_canvas.configure(scrollregion=remove_canvas.bbox("all"))
        )
        
        remove_canvas.create_window((0, 0), window=remove_scrollable, anchor="nw")
        remove_canvas.configure(yscrollcommand=remove_scrollbar.set)
        
        remove_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        remove_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        remove_vars = {}
        
        def select_all_remove():
            for var in remove_vars.values():
                var.set(True)
        
        def deselect_all_remove():
            for var in remove_vars.values():
                var.set(False)
        
        button_frame_remove = ttk.Frame(remove_scrollable)
        button_frame_remove.pack(anchor=tk.W, padx=5, pady=5)
        ttk.Button(button_frame_remove, text="Select All", command=select_all_remove, width=12).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame_remove, text="Deselect All", command=deselect_all_remove, width=12).pack(side=tk.LEFT, padx=2)
        
        for col in df.columns:
            var = tk.BooleanVar(value=False)
            remove_vars[col] = var
            cb = ttk.Checkbutton(remove_scrollable, text=col, variable=var)
            cb.pack(anchor=tk.W, padx=5, pady=2)
        
        result = {'default_columns': [], 'remove_columns': []}
        
        def confirm():
            result['default_columns'] = default_columns
            result['remove_columns'] = [col for col, var in remove_vars.items() if var.get()]
            popup.destroy()
        
        def cancel():
            popup.destroy()
        
        bottom_frame = ttk.Frame(popup)
        bottom_frame.pack(pady=10)
        ttk.Button(bottom_frame, text="Confirm", command=confirm).pack(side=tk.LEFT, padx=5)
        ttk.Button(bottom_frame, text="Cancel", command=cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        return result
    
    # METHOD: Rename columns including blank headers
    def rename_columns(self, df):
        """Step B: Rename columns (including blank/null headers)"""
        popup = tk.Toplevel(self.root)
        popup.title("Rename Columns")
        popup.geometry("900x600")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Step B: Rename Columns", 
                 font=('TkDefaultFont', 11, 'bold')).pack(pady=10)
        
        ttk.Label(popup, text="Edit the 'New Name' column to rename. Leave blank for empty header.", 
                 font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
        
        main_container = ttk.Frame(popup)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        canvas = tk.Canvas(main_container, highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        header_frame = ttk.Frame(scrollable_frame, relief=tk.RIDGE, borderwidth=2)
        header_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=2, pady=2)
        
        ttk.Label(header_frame, text="Original Column Name", 
                 font=('TkDefaultFont', 9, 'bold'), 
                 width=35, anchor=tk.W, 
                 background='#e0e0e0').grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        
        ttk.Label(header_frame, text="→", 
                 font=('TkDefaultFont', 12, 'bold'),
                 width=3, anchor=tk.CENTER).grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(header_frame, text="New Column Name (Editable)", 
                 font=('TkDefaultFont', 9, 'bold'), 
                 width=35, anchor=tk.W,
                 background='#ffe0b3').grid(row=0, column=2, padx=5, pady=5, sticky=tk.W)
        
        entry_widgets = {}
        
        for idx, col in enumerate(df.columns, start=1):
            row_frame = ttk.Frame(scrollable_frame)
            row_frame.grid(row=idx, column=0, sticky=(tk.W, tk.E), padx=2, pady=1)
            
            original_frame = tk.Frame(row_frame, relief=tk.SOLID, borderwidth=1, bg='#f5f5f5')
            original_frame.grid(row=0, column=0, padx=2, pady=2, sticky=(tk.W, tk.E))
            
            original_label = tk.Label(original_frame, text=col, 
                                     anchor=tk.W, bg='#f5f5f5',
                                     width=40, padx=5, pady=5)
            original_label.pack(fill=tk.BOTH)
            
            arrow_label = ttk.Label(row_frame, text="→", 
                                   font=('TkDefaultFont', 12))
            arrow_label.grid(row=0, column=1, padx=5)
            
            entry_frame = tk.Frame(row_frame, relief=tk.SOLID, borderwidth=2, bg='#fff8dc')
            entry_frame.grid(row=0, column=2, padx=2, pady=2, sticky=(tk.W, tk.E))
            
            entry = tk.Entry(entry_frame, width=40, 
                           font=('TkDefaultFont', 9),
                           bg='#fffaed', relief=tk.FLAT)
            entry.insert(0, col)
            entry.pack(fill=tk.BOTH, padx=3, pady=3)
            entry_widgets[col] = entry
            
            row_frame.columnconfigure(0, weight=1)
            row_frame.columnconfigure(2, weight=1)
        
        scrollable_frame.columnconfigure(0, weight=1)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        def on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        canvas.bind_all("<MouseWheel>", on_mousewheel)
        
        info_frame = ttk.Frame(popup)
        info_frame.pack(fill=tk.X, padx=10, pady=5)
        
        info_label = ttk.Label(info_frame, 
                              text=f"Total columns: {len(df.columns)} | Tip: Leave field blank for empty header", 
                              font=('TkDefaultFont', 9), foreground='blue')
        info_label.pack(side=tk.LEFT)
        
        result = {}
        
        def confirm():
            rename_map = {}
            for original, entry in entry_widgets.items():
                new_name = entry.get().strip()
                rename_map[original] = new_name
            
            result['rename_map'] = rename_map
            canvas.unbind_all("<MouseWheel>")
            popup.destroy()
        
        def reset():
            for original, entry in entry_widgets.items():
                entry.delete(0, tk.END)
                entry.insert(0, original)
        
        def clear_all():
            response = messagebox.askyesno("Clear All", 
                "Are you sure you want to clear all new column names?")
            if response:
                for entry in entry_widgets.values():
                    entry.delete(0, tk.END)
        
        def cancel():
            canvas.unbind_all("<MouseWheel>")
            popup.destroy()
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=10)
        ttk.Button(button_frame, text="Reset All", command=reset).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Clear All", command=clear_all).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Confirm", command=confirm, style='Accent.TButton').pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        return result
    
    # METHOD: Sequence columns
    def sequence_columns(self, df):
        """Step C: Set column sequence"""
        popup = tk.Toplevel(self.root)
        popup.title("Sequence Columns")
        popup.geometry("500x550")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Step C: Set Column Sequence", 
                 font=('TkDefaultFont', 11, 'bold')).pack(pady=10)
        
        ttk.Label(popup, text="Arrange columns in desired order (use buttons to move):", 
                 font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
        
        list_frame = ttk.Frame(popup)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        column_listbox = tk.Listbox(list_frame, height=18)
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=column_listbox.yview)
        column_listbox.configure(yscrollcommand=scrollbar.set)
        column_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        for col in df.columns:
            column_listbox.insert(tk.END, col)
        
        def move_up():
            selection = column_listbox.curselection()
            if selection and selection[0] > 0:
                idx = selection[0]
                item = column_listbox.get(idx)
                column_listbox.delete(idx)
                column_listbox.insert(idx - 1, item)
                column_listbox.selection_set(idx - 1)
        
        def move_down():
            selection = column_listbox.curselection()
            if selection and selection[0] < column_listbox.size() - 1:
                idx = selection[0]
                item = column_listbox.get(idx)
                column_listbox.delete(idx)
                column_listbox.insert(idx + 1, item)
                column_listbox.selection_set(idx + 1)
        
        def move_top():
            selection = column_listbox.curselection()
            if selection:
                idx = selection[0]
                item = column_listbox.get(idx)
                column_listbox.delete(idx)
                column_listbox.insert(0, item)
                column_listbox.selection_set(0)
        
        def move_bottom():
            selection = column_listbox.curselection()
            if selection:
                idx = selection[0]
                item = column_listbox.get(idx)
                column_listbox.delete(idx)
                column_listbox.insert(tk.END, item)
                column_listbox.selection_set(column_listbox.size() - 1)
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=5)
        
        ttk.Button(button_frame, text="↑ Move Up", command=move_up, width=15).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="↓ Move Down", command=move_down, width=15).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="⇈ Move to Top", command=move_top, width=15).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="⇊ Move to Bottom", command=move_bottom, width=15).pack(side=tk.LEFT, padx=2)
        
        result = {}
        
        def use_default():
            result['sequence'] = None
            popup.destroy()
        
        def confirm():
            result['sequence'] = [column_listbox.get(i) for i in range(column_listbox.size())]
            popup.destroy()
        
        def cancel():
            popup.destroy()
        
        confirm_frame = ttk.Frame(popup)
        confirm_frame.pack(pady=10)
        ttk.Button(confirm_frame, text="Use Default Order", command=use_default).pack(side=tk.LEFT, padx=5)
        ttk.Button(confirm_frame, text="Apply Custom Order", command=confirm).pack(side=tk.LEFT, padx=5)
        ttk.Button(confirm_frame, text="Cancel", command=cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        return result
    
    # Method to show completion popup
    def show_completion_popup(self):
        """Show popup asking user what to do next"""
        popup = tk.Toplevel(self.root)
        popup.title("Processing Complete")
        popup.geometry("300x150")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Data exported successfully!", 
                 font=('TkDefaultFont', 10, 'bold')).pack(pady=20)
        
        ttk.Label(popup, text="What would you like to do next?").pack(pady=5)
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=20)
        
        def continue_working():
            popup.destroy()
        
        def close_application():
            popup.destroy()
            self.root.destroy()
        
        ttk.Button(button_frame, text="Continue Working", 
                  command=continue_working).pack(side=tk.LEFT, padx=10)
        ttk.Button(button_frame, text="Close Application", 
                  command=close_application).pack(side=tk.LEFT, padx=10)
    
    # UPDATED METHOD: Export data with column management
    def export_data(self):
        if not self.processed_data:
            messagebox.showwarning("Warning", "No processed data to export")
            return
        
        df_export = pd.DataFrame(self.processed_data)
        
        # Step A: Manage default columns
        step_a_result = self.manage_default_columns(df_export)
        
        if not step_a_result:
            return
        
        # Apply default column additions
        for new_col, source_col, mapping_dict in step_a_result['default_columns']:
            if source_col in df_export.columns:
                def map_value(val):
                    val_str = str(val) if pd.notna(val) else ""
                    if val_str in mapping_dict:
                        return mapping_dict[val_str]
                    elif '*' in mapping_dict:
                        return mapping_dict['*']
                    else:
                        return ""
                
                df_export[new_col] = df_export[source_col].apply(map_value)
        
        # Remove columns marked for removal
        if step_a_result['remove_columns']:
            df_export = df_export.drop(columns=step_a_result['remove_columns'], errors='ignore')
        
        # Remove duplicate rows after column removal
        df_export = df_export.drop_duplicates()
        
        # Step B: Rename columns
        step_b_result = self.rename_columns(df_export)
        
        if not step_b_result:
            return
        
        if 'rename_map' in step_b_result:
            rename_map = step_b_result['rename_map']
            df_export = df_export.rename(columns=rename_map)
        
        # Step C: Sequence columns
        step_c_result = self.sequence_columns(df_export)
        
        if not step_c_result:
            return
        
        if 'sequence' in step_c_result and step_c_result['sequence']:
            df_export = df_export[step_c_result['sequence']]
        
        # Now proceed with file export
        file_path = filedialog.asksaveasfilename(
            title="Save Processed Data",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                if file_path.endswith('.xlsx'):
                    df_export.to_excel(file_path, index=False)
                else:
                    df_export.to_csv(file_path, index=False)
                
                messagebox.showinfo("Success", 
                    f"Data exported successfully to {os.path.basename(file_path)}\n"
                    f"Total rows: {len(df_export)}\n"
                    f"Total columns: {len(df_export.columns)}")
                self.status_var.set(f"Data exported to {os.path.basename(file_path)}")
                
                self.show_completion_popup()
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export data: {str(e)}")

# Main function
def main():
    root = tk.Tk()
    app = CSVProcessorGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()