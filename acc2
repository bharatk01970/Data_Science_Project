# Instructions
        ttk.Label(popup, text="Step A: Add Default Columns & Remove Existing Columns", 
                 font=('TkDefaultFont', 11, 'bold')).pack(pady=10)
        
        notebook = ttk.Notebook(popup)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Tab 1: Add Default Columns
        add_frame = ttk.Frame(notebook)
        notebook.add(add_frame, text="Add Default Columns")
        
        ttk.Label(add_frame, text="Add new columns with default values based on existing columns:", 
                 font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
        
        # Frame for column additions
        add_list_frame = ttk.Frame(add_frame)
        add_list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        add_listbox = tk.Listbox(add_list_frame, height=10)
        add_scrollbar = ttk.Scrollbar(add_list_frame, orient="vertical", command=add_listbox.yview)
        add_listbox.configure(yscrollcommand=add_scrollbar.set)
        add_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        add_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        default_columns = []  # Store (new_col_name, source_col, mapping_dict)
        
        def add_default_column():
            # Dialog to get new column details
            detail_popup = tk.Toplevel(popup)
            detail_popup.title("Add Default Column")
            detail_popup.geometry("500x400")
            detail_popup.transient(popup)
            detail_popup.grab_set()
            
            ttk.Label(detail_popup, text="New Column Name:").grid(row=0, column=0, sticky=tk.W, padx=10, pady=5)
            new_col_entry = ttk.Entry(detail_popup, width=30)
            new_col_entry.grid(row=0, column=1, padx=10, pady=5)
            
            ttk.Label(detail_popup, text="Source Column:").grid(row=1, column=0, sticky=tk.W, padx=10, pady=5)
            source_var = tk.StringVar()
            source_combo = ttk.Combobox(detail_popup, textvariable=source_var, width=28, state='readonly')
            source_combo['values'] = list(df.columns)
            source_combo.grid(row=1, column=1, padx=10, pady=5)
            
            ttk.Label(detail_popup, text="Value Mapping (format: source_value=default_value, one per line):", 
                     font=('TkDefaultFont', 9)).grid(row=2, column=0, columnspan=2, sticky=tk.W, padx=10, pady=(10, 5))
            
            mapping_text = tk.Text(detail_popup, height=10, width=50)
            mapping_text.grid(row=3, column=0, columnspan=2, padx=10, pady=5)
            
            ttk.Label(detail_popup, text="Example:\nValue1=DefaultA\nValue2=DefaultB\n*=DefaultForAll", 
                     font=('TkDefaultFont', 8), foreground='gray').grid(row=4, column=0, columnspan=2, sticky=tk.W, padx=10)
            
            def save_mapping():
                new_col = new_col_entry.get().strip()
                source_col = source_var.get().strip()
                
                if not new_col:
                    messagebox.showwarning("Warning", "Please enter a new column name")
                    return
                if not source_col:
                    messagebox.showwarning("Warning", "Please select a source column")
                    return
                
                # Parse mapping
                mapping_dict = {}
                mapping_lines = mapping_text.get("1.0", tk.END).strip().split('\n')
                for line in mapping_lines:
                    if '=' in line:
                        key, val = line.split('=', 1)
                        mapping_dict[key.strip()] = val.strip()
                
                if not mapping_dict:
                    messagebox.showwarning("Warning", "Please provide at least one value mapping")
                    return
                
                default_columns.append((new_col, source_col, mapping_dict))
                add_listbox.insert(tk.END, f"{new_col} ← {source_col}")
                detail_popup.destroy()
            
            ttk.Button(detail_popup, text="Save", command=save_mapping).grid(row=5, column=0, columnspan=2, pady=10)
        
        def remove_default_column():
            selection = add_listbox.curselection()
            if selection:
                idx = selection[0]
                add_listbox.delete(idx)
                default_columns.pop(idx)
        
        button_frame1 = ttk.Frame(add_frame)
        button_frame1.pack(pady=5)
        ttk.Button(button_frame1, text="Add Column", command=add_default_column).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame1, text="Remove Selected", command=remove_default_column).pack(side=tk.LEFT, padx=5)
        
        # Tab 2: Remove Columns
        remove_frame = ttk.Frame(notebook)
        notebook.add(remove_frame, text="Remove Columns")
        
        ttk.Label(remove_frame, text="Select columns to remove from final output:", 
                 font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
        
        remove_list_frame = ttk.Frame(remove_frame)
        remove_list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        remove_listbox = tk.Listbox(remove_list_frame, selectmode=tk.MULTIPLE, height=15)
        remove_scrollbar = ttk.Scrollbar(remove_list_frame, orient="vertical", command=remove_listbox.yview)
        remove_listbox.configure(yscrollcommand=remove_scrollbar.set)
        remove_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        remove_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        for col in df.columns:
            remove_listbox.insert(tk.END, col)
        
        result = {'default_columns': [], 'remove_columns': []}
        
        def confirm():
            result['default_columns'] = default_columns
            selected_indices = remove_listbox.curselection()
            result['remove_columns'] = [df.columns[i] for i in selected_indices]
            popup.destroy()
        
        def cancel():
            popup.destroy()
        
        # Bottom buttons
        bottom_frame = ttk.Frame(popup)
        bottom_frame.pack(pady=10)
        ttk.Button(bottom_frame, text="Confirm", command=confirm).pack(side=tk.LEFT, padx=5)
        ttk.Button(bottom_frame, text="Cancel", command=cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        return result
    
    # NEW METHOD: Rename columns including blank headers
    def rename_columns(self, df):
        """Step B: Rename columns (including blank/null headers)"""
        popup = tk.Toplevel(self.root)
        popup.title("Rename Columns")
        popup.geometry("900x600")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Step B: Rename Columns", 
                 font=('TkDefaultFont', 11, 'bold')).pack(pady=10)
        
        ttk.Label(popup, text="Edit the 'New Name' column to rename. Leave blank for empty header.", 
                 font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
        
        # Main container frame
        main_container = ttk.Frame(popup)
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Create canvas with scrollbar for the grid
        canvas = tk.Canvas(main_container, highlightthickness=0)
        scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Header row
        header_frame = ttk.Frame(scrollable_frame, relief=tk.RIDGE, borderwidth=2)
        header_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), padx=2, pady=2)
        
        ttk.Label(header_frame, text="Original Column Name", 
                 font=('TkDefaultFont', 9, 'bold'), 
                 width=35, anchor=tk.W, 
                 background='#e0e0e0').grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        
        ttk.Label(header_frame, text="→", 
                 font=('TkDefaultFont', 12, 'bold'),
                 width=3, anchor=tk.CENTER).grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(header_frame, text="New Column Name (Editable)", 
                 font=('TkDefaultFont', 9, 'bold'), 
                 width=35, anchor=tk.W,
                 background='#ffe0b3').grid(row=0, column=2, padx=5, pady=5, sticky=tk.W)
        
        # Store entry widgets
        entry_widgets = {}
        
        # Create rows for each column
        for idx, col in enumerate(df.columns, start=1):
            row_frame = ttk.Frame(scrollable_frame)
            row_frame.grid(row=idx, column=0, sticky=(tk.W, tk.E), padx=2, pady=1)
            
            # Original name (read-only, with light gray background)
            original_frame = tk.Frame(row_frame, relief=tk.SOLID, borderwidth=1, bg='#f5f5f5')
            original_frame.grid(row=0, column=0, padx=2, pady=2, sticky=(tk.W, tk.E))
            
            original_label = tk.Label(original_frame, text=col, 
                                     anchor=tk.W, bg='#f5f5f5',
                                     width=40, padx=5, pady=5)
            original_label.pack(fill=tk.BOTH)
            
            # Arrow
            arrow_label = ttk.Label(row_frame, text="→", 
                                   font=('TkDefaultFont', 12))
            arrow_label.grid(row=0, column=1, padx=5)
            
            # New name (editable, with light orange/yellow background box)
            entry_frame = tk.Frame(row_frame, relief=tk.SOLID, borderwidth=2, bg='#fff8dc')
            entry_frame.grid(row=0, column=2, padx=2, pady=2, sticky=(tk.W, tk.E))
            
            entry = tk.Entry(entry_frame, width=40, 
                           font=('TkDefaultFont', 9),
                           bg='#fffaed', relief=tk.FLAT)
            entry.insert(0, col)
            entry.pack(fill=tk.BOTH, padx=3, pady=3)
            entry_widgets[col] = entry
            
            row_frame.columnconfigure(0, weight=1)
            row_frame.columnconfigure(2, weight=1)
        
        # Configure scrollable frame
        scrollable_frame.columnconfigure(0, weight=1)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Enable mouse wheel scrolling
        def on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        canvas.bind_all("<MouseWheel>", on_mousewheel)
        
        # Info label
        info_frame = ttk.Frame(popup)
        info_frame.pack(fill=tk.X, padx=10, pady=5)
        
        info_label = ttk.Label(info_frame, 
                              text=f"Total columns: {len(df.columns)} | Tip: Leave field blank for empty header", 
                              font=('TkDefaultFont', 9), foreground='blue')
        info_label.pack(side=tk.LEFT)
        
        result = {}
        
        def confirm():
            # Collect all entries
            rename_map = {}
            for original, entry in entry_widgets.items():
                new_name = entry.get().strip()
                rename_map[original] = new_name
            
            result['rename_map'] = rename_map
            canvas.unbind_all("<MouseWheel>")
            popup.destroy()
        
        def reset():
            """Reset all mappings to original names"""
            for original, entry in entry_widgets.items():
                entry.delete(0, tk.END)
                entry.insert(0, original)
        
        def clear_all():
            """Clear all new names"""
            response = messagebox.askyesno("Clear All", 
                "Are you sure you want to clear all new column names?")
            if response:
                for entry in entry_widgets.values():
                    entry.delete(0, tk.END)
        
        def cancel():
            canvas.unbind_all("<MouseWheel>")
            popup.destroy()
        
        # Buttons
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=10)
        ttk.Button(button_frame, text="Reset All", command=reset).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Clear All", command=clear_all).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Confirm", command=confirm, style='Accent.TButton').pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        return result
    
    # NEW METHOD: Sequence columns
    def sequence_columns(self, df):
        """Step C: Set column sequence"""
        popup = tk.Toplevel(self.root)
        popup.title("Sequence Columns")
        popup.geometry("500x550")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Step C: Set Column Sequence", 
                 font=('TkDefaultFont', 11, 'bold')).pack(pady=10)
        
        ttk.Label(popup, text="Arrange columns in desired order (use buttons to move):", 
                 font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
        
        # Create frame with listbox
        list_frame = ttk.Frame(popup)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        column_listbox = tk.Listbox(list_frame, height=18)
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=column_listbox.yview)
        column_listbox.configure(yscrollcommand=scrollbar.set)
        column_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        for col in df.columns:
            column_listbox.insert(tk.END, col)
        
        def move_up():
            selection = column_listbox.curselection()
            if selection and selection[0] > 0:
                idx = selection[0]
                item = column_listbox.get(idx)
                column_listbox.delete(idx)
                column_listbox.insert(idx - 1, item)
                column_listbox.selection_set(idx - 1)
        
        def move_down():
            selection = column_listbox.curselection()
            if selection and selection[0] < column_listbox.size() - 1:
                idx = selection[0]
                item = column_listbox.get(idx)
                column_listbox.delete(idx)
                column_listbox.insert(idx + 1, item)
                column_listbox.selection_set(idx + 1)
        
        def move_top():
            selection = column_listbox.curselection()
            if selection:
                idx = selection[0]
                item = column_listbox.get(idx)
                column_listbox.delete(idx)
                column_listbox.insert(0, item)
                column_listbox.selection_set(0)
        
        def move_bottom():
            selection = column_listbox.curselection()
            if selection:
                idx = selection[0]
                item = column_listbox.get(idx)
                column_listbox.delete(idx)
                column_listbox.insert(tk.END, item)
                column_listbox.selection_set(column_listbox.size() - 1)
        
        # Movement buttons
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=5)
        
        ttk.Button(button_frame, text="↑ Move Up", command=move_up, width=15).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="↓ Move Down", command=move_down, width=15).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="⇈ Move to Top", command=move_top, width=15).pack(side=tk.LEFT, padx=2)
        ttk.Button(button_frame, text="⇊ Move to Bottom", command=move_bottom, width=15).pack(side=tk.LEFT, padx=2)
        
        result = {}
        
        def use_default():
            result['sequence'] = None  # Use default order
            popup.destroy()
        
        def confirm():
            result['sequence'] = [column_listbox.get(i) for i in range(column_listbox.size())]
            popup.destroy()
        
        def cancel():
            popup.destroy()
        
        # Confirm buttons
        confirm_frame = ttk.Frame(popup)
        confirm_frame.pack(pady=10)
        ttk.Button(confirm_frame, text="Use Default Order", command=use_default).pack(side=tk.LEFT, padx=5)
        ttk.Button(confirm_frame, text="Apply Custom Order", command=confirm).pack(side=tk.LEFT, padx=5)
        ttk.Button(confirm_frame, text="Cancel", command=cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        return result
    
    # Method to show completion popup
    def show_completion_popup(self):
        """Show popup asking user what to do next"""
        popup = tk.Toplevel(self.root)
        popup.title("Processing Complete")
        popup.geometry("300x150")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Data exported successfully!", 
                 font=('TkDefaultFont', 10, 'bold')).pack(pady=20)
        
        ttk.Label(popup, text="What would you like to do next?").pack(pady=5)
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=20)
        
        def continue_working():
            popup.destroy()
        
        def close_application():
            popup.destroy()
            self.root.destroy()
        
        ttk.Button(button_frame, text="Continue Working", 
                  command=continue_working).pack(side=tk.LEFT, padx=10)
        ttk.Button(button_frame, text="Close Application", 
                  command=close_application).pack(side=tk.LEFT, padx=10)
    
    # UPDATED METHOD: Export data with column management
    def export_data(self):
        if not self.processed_data:
            messagebox.showwarning("Warning", "No processed data to export")
            return
        
        # Convert to DataFrame for easier manipulation
        df_export = pd.DataFrame(self.processed_data)
        
        # Step A: Manage default columns (add new, remove existing)
        step_a_result = self.manage_default_columns(df_export)
        
        if not step_a_result:  # User cancelled
            return
        
        # Apply default column additions
        for new_col, source_col, mapping_dict in step_a_result['default_columns']:
            if source_col in df_export.columns:
                def map_value(val):
                    val_str = str(val) if pd.notna(val) else ""
                    # Check for exact match
                    if val_str in mapping_dict:
                        return mapping_dict[val_str]
                    # Check for wildcard
                    elif '*' in mapping_dict:
                        return mapping_dict['*']
                    else:
                        return ""
                
                df_export[new_col] = df_export[source_col].apply(map_value)
        
        # Remove columns marked for removal
        if step_a_result['remove_columns']:
            df_export = df_export.drop(columns=step_a_result['remove_columns'], errors='ignore')
        
        # Remove duplicate rows after column removal
        df_export = df_export.drop_duplicates()
        
        # Step B: Rename columns
        step_b_result = self.rename_columns(df_export)
        
        if not step_b_result:  # User cancelled
            return
        
        if 'rename_map' in step_b_result:
            rename_map = step_b_result['rename_map']
            df_export = df_export.rename(columns=rename_map)
        
        # Step C: Sequence columns
        step_c_result = self.sequence_columns(df_export)
        
        if not step_c_result:  # User cancelled
            return
        
        if 'sequence' in step_c_result and step_c_result['sequence']:
            # Reorder columns according to user preference
            df_export = df_export[step_c_result['sequence']]
        
        # Now proceed with file export
        file_path = filedialog.asksaveasfilename(
            title="Save Processed Data",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                if file_path.endswith('.xlsx'):
                    df_export.to_excel(file_path, index=False)
                else:
                    df_export.to_csv(file_path, index=False)
                
                messagebox.showinfo("Success", 
                    f"Data exported successfully to {os.path.basename(file_path)}\n"
                    f"Total rows: {len(df_export)}\n"
                    f"Total columns: {len(df_export.columns)}")
                self.status_var.set(f"Data exported to {os.path.basename(file_path)}")
                
                self.show_completion_popup()
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export data: {str(e)}")

# Main function
def main():
    root = tk.Tk()
    app = CSVProcessorGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()