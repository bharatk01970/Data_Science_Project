def show_column_combination_popup(self, columns):
    """Show popup to select columns for combination with optional reference-based repetition"""
    popup = tk.Toplevel(self.root)
    popup.title("Column Combination & Reference-Based Repetition")
    popup.geometry("550x700")
    popup.transient(self.root)
    popup.grab_set()
    
    ttk.Label(popup, text="Column Combination & Reference-Based Repetition", 
              font=('TkDefaultFont', 11, 'bold')).pack(pady=10)
    
    # Create notebook for two steps
    notebook = ttk.Notebook(popup)
    notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
    
    # STEP 1: Column Combination (Required for Step 2)
    combine_frame = ttk.Frame(notebook)
    notebook.add(combine_frame, text="Step 1: Combine Columns")
    
    ttk.Label(combine_frame, text="Select columns to combine into a single column:", 
              font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
    ttk.Label(combine_frame, text="(This is the base for reference-based repetition)", 
              font=('TkDefaultFont', 8), foreground='gray').pack(pady=2, padx=10, anchor=tk.W)
    
    # Create scrollable frame for checkboxes
    canvas_frame1 = ttk.Frame(combine_frame)
    canvas_frame1.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
    
    canvas1 = tk.Canvas(canvas_frame1, highlightthickness=0)
    scrollbar1 = ttk.Scrollbar(canvas_frame1, orient="vertical", command=canvas1.yview)
    scrollable_frame1 = ttk.Frame(canvas1)
    
    scrollable_frame1.bind(
        "<Configure>",
        lambda e: canvas1.configure(scrollregion=canvas1.bbox("all"))
    )
    
    canvas1.create_window((0, 0), window=scrollable_frame1, anchor="nw")
    canvas1.configure(yscrollcommand=scrollbar1.set)
    
    canvas1.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar1.pack(side=tk.RIGHT, fill=tk.Y)
    
    # Create checkboxes for each column
    column_vars = {}
    for col in sorted(columns):
        var = tk.BooleanVar(value=False)
        column_vars[col] = var
        cb = ttk.Checkbutton(scrollable_frame1, text=col, variable=var)
        cb.pack(anchor=tk.W, padx=5, pady=2)
    
    # STEP 2: Reference-Based Repetition (Optional)
    reference_frame = ttk.Frame(notebook)
    notebook.add(reference_frame, text="Step 2: Reference Repetition (Optional)")
    
    ttk.Label(reference_frame, text="Select reference column(s) for repetition:", 
              font=('TkDefaultFont', 9)).pack(pady=5, padx=10, anchor=tk.W)
    ttk.Label(reference_frame, text="Values from other columns in the combined column will repeat\nbased on the count of values in the reference column(s).", 
              font=('TkDefaultFont', 8), foreground='gray').pack(pady=2, padx=10, anchor=tk.W)
    
    ttk.Label(reference_frame, text="Example: If A has 5 values and B (reference) has 2 values,\nA's values will appear twice in the combined column.", 
              font=('TkDefaultFont', 8), foreground='blue').pack(pady=5, padx=10, anchor=tk.W)
    
    # Create scrollable frame for reference column checkboxes
    canvas_frame2 = ttk.Frame(reference_frame)
    canvas_frame2.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
    
    canvas2 = tk.Canvas(canvas_frame2, highlightthickness=0)
    scrollbar2 = ttk.Scrollbar(canvas_frame2, orient="vertical", command=canvas2.yview)
    scrollable_frame2 = ttk.Frame(canvas2)
    
    scrollable_frame2.bind(
        "<Configure>",
        lambda e: canvas2.configure(scrollregion=canvas2.bbox("all"))
    )
    
    canvas2.create_window((0, 0), window=scrollable_frame2, anchor="nw")
    canvas2.configure(yscrollcommand=scrollbar2.set)
    
    canvas2.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar2.pack(side=tk.RIGHT, fill=tk.Y)
    
    # Create checkboxes for reference columns
    reference_vars = {}
    for col in sorted(columns):
        var = tk.BooleanVar(value=False)
        reference_vars[col] = var
        cb = ttk.Checkbutton(scrollable_frame2, text=col, variable=var)
        cb.pack(anchor=tk.W, padx=5, pady=2)
    
    result = {'combine': False, 'columns': [], 'new_name': '', 'reference_columns': []}
    
    def confirm():
        selected_cols = [col for col, var in column_vars.items() if var.get()]
        selected_refs = [col for col, var in reference_vars.items() if var.get()]
        
        # Column combination is required
        if not selected_cols:
            messagebox.showwarning("Warning", "Please select at least one column in Step 1")
            return
        
        if len(selected_cols) < 2:
            messagebox.showwarning("Warning", "Please select at least 2 columns to combine")
            return
        
        # Check if reference columns are subset of combined columns
        if selected_refs:
            invalid_refs = [ref for ref in selected_refs if ref not in selected_cols]
            if invalid_refs:
                messagebox.showwarning("Warning", 
                    f"Reference columns must be from the columns selected for combination.\n"
                    f"Invalid selections: {', '.join(invalid_refs)}")
                return
        
        # Ask for new column name
        new_name = simpledialog.askstring(
            "Combined Column Name",
            f"Enter name for combined column containing values from:\n{', '.join(selected_cols)}",
            parent=popup
        )
        
        if new_name and new_name.strip():
            result['combine'] = True
            result['columns'] = selected_cols
            result['new_name'] = new_name.strip()
            result['reference_columns'] = selected_refs  # Can be empty list
            popup.destroy()
        else:
            messagebox.showwarning("Warning", "Please enter a valid column name")
    
    def skip():
        popup.destroy()
    
    button_frame = ttk.Frame(popup)
    button_frame.pack(pady=10)
    
    ttk.Label(button_frame, text="Note: Step 1 is required. Step 2 is optional.", 
              font=('TkDefaultFont', 8), foreground='gray').pack(side=tk.LEFT, padx=10)
    
    ttk.Button(button_frame, text="Apply", command=confirm).pack(side=tk.LEFT, padx=5)
    ttk.Button(button_frame, text="Skip (No Changes)", command=skip).pack(side=tk.LEFT, padx=5)
    
    popup.wait_window()
    return result








######


def apply_column_combination(self, result_rows, columns_to_combine, new_column_name, reference_columns=None):
    """Combine multiple columns into one with optional reference-based repetition"""
    if not columns_to_combine or not new_column_name:
        return result_rows
    
    combined_rows = []
    
    for row in result_rows:
        # Separate reference and non-reference columns
        ref_cols = reference_columns if reference_columns else []
        non_ref_cols = [col for col in columns_to_combine if col not in ref_cols]
        
        # Get reference column values if any
        ref_values_list = []
        if ref_cols:
            for ref_col in ref_cols:
                if ref_col in row and row[ref_col]:
                    value = row[ref_col]
                    if value:
                        values = [value] if not isinstance(value, list) else value
                        ref_values_list.extend([v for v in values if v])
        
        # If no reference columns or no reference values, use standard combination
        if not ref_values_list:
            ref_values_list = [None]  # Single iteration
        
        # For each reference value, create combined output
        for ref_val in ref_values_list:
            combined_values = []
            
            # Add all non-reference column values
            for col in non_ref_cols:
                if col in row and row[col]:
                    value = row[col]
                    if value:
                        # Split multi-values if needed
                        if isinstance(value, str) and (',' in value or ';' in value):
                            split_vals = self.split_multi_values(value)
                            combined_values.extend([v for v in split_vals if v])
                        else:
                            combined_values.append(value)
            
            # Add the reference value (if exists)
            if ref_val:
                combined_values.append(ref_val)
            
            # Create new row
            new_row = {}
            # Copy all columns except the ones being combined
            for key, val in row.items():
                if key not in columns_to_combine:
                    new_row[key] = val
            
            # Add the new combined column with comma-separated values
            new_row[new_column_name] = ', '.join([str(v) for v in combined_values]) if combined_values else ''
            
            # Avoid duplicate rows
            if new_row not in combined_rows:
                combined_rows.append(new_row)
    
    return combined_rows




######

combination_result = self.show_column_combination_popup(temp_stage1_columns)
            
            # Apply column combination if selected
            if combination_result.get('combine'):
                self.stage1_data = self.apply_column_combination(
                    temp_stage1_data,
                    combination_result['columns'],
                    combination_result['new_name']
                )
                self.status_var.set(f"Applied column combination: {combination_result['new_name']}")
            # Apply reference-based repetition if selected
            elif combination_result.get('reference_columns'):
                self.stage1_data = self.apply_reference_based_repetition(
                    temp_stage1_data,
                    combination_result['reference_columns'],
                    combination_result['combined_name']
                )
                ref_cols_str = ', '.join(combination_result['reference_columns'])
                self.status_var.set(f"Applied reference-based repetition using column(s): {ref_cols_str}")
                messagebox.showinfo("Reference-Based Repetition Applied", 
                                    f"Values repeated based on reference column(s): {ref_cols_str}\n"
                                    f"Combined column: {combination_result['combined_name']}\n"
                                    f"Total rows generated: {len(self.stage1_data)}")
            else:
                self.stage1_data = temp_stage1_data


@@@@

combination_result = self.show_column_combination_popup(temp_stage1_columns)
            
            # Apply column combination with optional reference-based repetition
            if combination_result.get('combine'):
                self.stage1_data = self.apply_column_combination(
                    temp_stage1_data,
                    combination_result['columns'],
                    combination_result['new_name'],
                    combination_result.get('reference_columns')  # Pass reference columns (can be empty list)
                )
                
                status_msg = f"Applied column combination: {combination_result['new_name']}"
                if combination_result.get('reference_columns'):
                    ref_cols_str = ', '.join(combination_result['reference_columns'])
                    status_msg += f" with reference-based repetition using: {ref_cols_str}"
                    messagebox.showinfo("Column Combination Complete", 
                                        f"Combined column: {combination_result['new_name']}\n"
                                        f"Reference columns for repetition: {ref_cols_str}\n"
                                        f"Total rows generated: {len(self.stage1_data)}")
                
                self.status_var.set(status_msg)
            else:
                self.stage1_data = temp_stage1_data
