def expand_combined_keys(self, field_expansions, combine_info):
    import itertools
    new_col = combine_info['new_col']
    keys = combine_info['keys']
    char_limits = combine_info['char_limits']

    truncated_lists = []
    for key in keys:
        vals = field_expansions.get(key, [""])
        # If the extracted list is empty, keep one empty string to preserve product
        if not vals:
            vals = [""]
        limit = char_limits.get(key, '*')
        if limit != '*':
            try:
                limit_int = int(limit)
                vals = [v[:limit_int] if v else "" for v in vals]
            except:
                pass
        truncated_lists.append(vals)

    # Ensure no empty iterable passed to product
    if not truncated_lists or any(len(v) == 0 for v in truncated_lists):
        return new_col, [""]

    product_tuples = list(itertools.product(*truncated_lists))

    combined_values = []
    for tup in product_tuples:
        # Reverse order for correct bÃ—a pattern
        for val in reversed(tup):
            combined_values.append(val)
    return new_col, combined_values