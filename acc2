# Method to show key selection popup
    def show_key_selection_popup(self, field, available_keys):
        """Show popup for key selection in dictionary fields with manual selection (nothing pre-selected)"""
        # Create popup window as child of main window
        popup = tk.Toplevel(self.root)
        # Set popup title with field name
        popup.title(f"Select Keys for Field: {field}")
        # Set popup dimensions - larger for better visibility
        popup.geometry("450x350")
        # Make popup transient to main window (stays on top)
        popup.transient(self.root)
        # Make popup modal (blocks interaction with parent)
        popup.grab_set()
        
        # Header frame with title and instructions
        header_frame = ttk.Frame(popup)
        header_frame.pack(pady=10, padx=10, fill=tk.X)
        
        # Main instruction label with bold formatting
        ttk.Label(header_frame, text=f"Select keys to include from field '{field}':", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W)
        
        # Helpful tip for users about multi-selection
        ttk.Label(header_frame, text="Tip: Click on keys to select them. Hold Ctrl/Cmd to select multiple.", 
                 font=('TkDefaultFont', 8), foreground='gray').pack(anchor=tk.W, pady=(2, 0))
        
        # Key selection frame with listbox and scrollbar
        key_frame = ttk.Frame(popup)
        key_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Create listbox for multiple key selection
        key_listbox = tk.Listbox(key_frame, selectmode=tk.MULTIPLE)
        # Create scrollbar for the key listbox
        key_scrollbar = ttk.Scrollbar(key_frame, orient="vertical", command=key_listbox.yview)
        # Connect scrollbar to listbox
        key_listbox.configure(yscrollcommand=key_scrollbar.set)
        
        # Pack listbox to fill available space
        key_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        # Pack scrollbar on right side
        key_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Populate listbox with available keys from dictionary field
        for key in available_keys:
            key_listbox.insert(tk.END, key)
        
        # IMPORTANT: DO NOT pre-select any keys - let user select manually
        # This line is intentionally commented out to show the change:
        # key_listbox.select_set(0, tk.END)  # REMOVED: No default selection
        
        # Status label to show real-time selection count
        status_label = ttk.Label(popup, text=f"0 of {len(available_keys)} keys selected", 
                                foreground='blue')
        status_label.pack(pady=(0, 5))
        
        # Function to update status label when selection changes
        def update_status(event=None):
            """Update the selection counter display"""
            count = len(key_listbox.curselection())
            status_label.config(text=f"{count} of {len(available_keys)} keys selected")
        
        # Bind listbox selection event to update function
        key_listbox.bind('<<ListboxSelect>>', update_status)
        
        # Initialize list to store user's key selections
        selected_keys = []
        
        # Function to select all keys at once
        def on_select_all():
            """Select all keys in the listbox"""
            key_listbox.select_set(0, tk.END)
            update_status()
        
        # Function to clear all selections
        def on_clear_all():
            """Clear all selections in the listbox"""
            key_listbox.selection_clear(0, tk.END)
            update_status()
        
        # Function to handle confirm button click
        def on_confirm():
            """Confirm selection and return selected keys"""
            # Access outer scope variable
            nonlocal selected_keys
            # Get indices of selected items
            selected_indices = key_listbox.curselection()
            # Convert indices to actual key names
            selected_keys = [available_keys[i] for i in selected_indices]
            # Close popup window
            popup.destroy()
        
        # Function to handle cancel button click
        def on_cancel():
            """Cancel selection and return empty list"""
            # Access outer scope variable
            nonlocal selected_keys
            # Clear selection list
            selected_keys = []
            # Close popup window
            popup.destroy()
        
        # Helper button frame for Select All and Clear All buttons
        helper_button_frame = ttk.Frame(popup)
        helper_button_frame.pack(pady=(5, 5))
        
        # Create "Select All" button for quick full selection
        ttk.Button(helper_button_frame, text="Select All", 
                  command=on_select_all).pack(side=tk.LEFT, padx=5)
        
        # Create "Clear All" button for quick deselection
        ttk.Button(helper_button_frame, text="Clear All", 
                  command=on_clear_all).pack(side=tk.LEFT, padx=5)
        
        # Main action button frame
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=10)
        
        # Create confirm button with descriptive label
        ttk.Button(button_frame, text="Confirm Selection", 
                  command=on_confirm).pack(side=tk.LEFT, padx=5)
        
        # Create cancel button
        ttk.Button(button_frame, text="Cancel", 
                  command=on_cancel).pack(side=tk.LEFT, padx=5)
        
        # Wait for popup window to be closed before continuing
        popup.wait_window()
        
        # Return user's key selections (empty list if cancelled or nothing selected)
        return selected_keys