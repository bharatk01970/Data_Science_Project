# Import tkinter for GUI framework - provides window management and user interface components
import tkinter as tk
# Import ttk for themed tkinter widgets - provides modern styled GUI elements
from tkinter import ttk, filedialog, messagebox, simpledialog
# Import pandas for data manipulation - handles CSV/Excel file reading and DataFrame operations
import pandas as pd
# Import json for JSON parsing - attempts to parse dictionary-like strings as JSON objects
import json
# Import ast for abstract syntax tree evaluation - safely evaluates Python literal expressions
import ast
# Import os for operating system interface - handles file path operations and system interactions
import os
# Import typing for type hints - provides static type checking support
from typing import Dict, List, Any, Optional
# Import chardet for automatic encoding detection
import chardet

# Define the main GUI application class that encapsulates all CSV processing functionality
class CSVProcessorGUI:
    # Constructor method that initializes the GUI application and sets up initial state
    def __init__(self, root):
        # Store reference to the main tkinter root window for later use
        self.root = root
        # Set the window title that appears in the title bar
        self.root.title("CSV Dictionary Field Processor - Two-Stage Processing")
        # Set the initial window size (width x height in pixels)
        self.root.geometry("750x600")
        
        # Initialize empty string to store the path of the selected input file
        self.input_file_path = ""
        # Initialize empty dictionary to store mapping between field names and their mapping file paths
        self.mapping_files = {}
        # Initialize None to store the loaded pandas DataFrame containing the input data
        self.df = None
        # Initialize empty list to store field names selected by the user for processing
        self.selected_fields = []
        # Initialize empty dictionary to store fields identified as containing dictionary-like data
        self.dictionary_fields = {}
        # Initialize empty dictionary to store user-selected keys for each dictionary field
        self.selected_keys = {}
        # Initialize None to store the final processed data after transformation
        self.processed_data = None
        # Initialize empty dictionary to store loaded mapping data as DataFrames
        self.mapping_data = {}
        # Initialize None to store stage 1 processed data before mapping
        self.stage1_data = None
        # Initialize flag to track if stage 1 processing is complete
        self.stage1_complete = False
        # Initialize dictionary for column renaming
        self.column_rename_map = {}
        # Initialize list for column sequence
        self.column_sequence = []
        # Initialize dictionary for default columns
        self.default_columns = {}
        
        # Call the UI setup method to create and arrange all GUI components
        self.setup_ui()
    
    # Method to create and configure all GUI elements and their layout
    def setup_ui(self):
        # Create the main container frame with padding for visual spacing
        main_frame = ttk.Frame(self.root, padding="10")
        # Place the main frame in the root window using grid layout manager
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure the root window's first column to expand horizontally when window resizes
        self.root.columnconfigure(0, weight=1)
        # Configure the root window's first row to expand vertically when window resizes
        self.root.rowconfigure(0, weight=1)
        # Configure the main frame's second column to expand horizontally
        main_frame.columnconfigure(1, weight=1)
        
        # Create section header label for file loading with bold font
        ttk.Label(main_frame, text="1. Load Input File:", font=('TkDefaultFont', 10, 'bold')).grid(
            row=0, column=0, columnspan=2, sticky=tk.W, pady=(0, 5))
        
        # Create button to trigger file selection dialog
        ttk.Button(main_frame, text="Select Input File", 
                  command=self.load_input_file).grid(row=1, column=0, sticky=tk.W, pady=(0, 10))
        
        # Create label to display the name of the selected input file
        self.input_file_label = ttk.Label(main_frame, text="No file selected")
        self.input_file_label.grid(row=1, column=1, sticky=tk.W, padx=(10, 0), pady=(0, 10))
        
        # Create section header label for field selection
        ttk.Label(main_frame, text="2. Select Fields for Processing:", 
                 font=('TkDefaultFont', 10, 'bold')).grid(
            row=2, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        # Create container frame for field selection controls
        field_frame = ttk.Frame(main_frame)
        field_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        field_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(3, weight=1)
        
        # Create sub-frame for field listbox with scrollbar
        field_scroll_frame = ttk.Frame(field_frame)
        field_scroll_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        field_scroll_frame.columnconfigure(0, weight=1)
        field_scroll_frame.rowconfigure(0, weight=1)
        
        # Create listbox for field selection with multiple selection enabled
        self.field_listbox = tk.Listbox(field_scroll_frame, selectmode=tk.MULTIPLE, height=6)
        field_scrollbar = ttk.Scrollbar(field_scroll_frame, orient="vertical", command=self.field_listbox.yview)
        self.field_listbox.configure(yscrollcommand=field_scrollbar.set)
        
        self.field_listbox.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        field_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # Create section header label for stage 1 processing
        ttk.Label(main_frame, text="3. Stage 1 Processing:", 
                 font=('TkDefaultFont', 10, 'bold')).grid(
            row=4, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        # Create button for stage 1 processing
        self.stage1_button = ttk.Button(main_frame, text="Process Stage 1 (Dictionary Expansion)", 
                  command=self.process_stage1, state='disabled')
        self.stage1_button.grid(row=5, column=0, sticky=tk.W, pady=(0, 10))
        
        # Create label to show stage 1 status
        self.stage1_status_label = ttk.Label(main_frame, text="")
        self.stage1_status_label.grid(row=5, column=1, sticky=tk.W, padx=(10, 0), pady=(0, 10))
        
        # Create section header label for mapping files functionality
        ttk.Label(main_frame, text="4. Load Mapping Files (Optional):", 
                 font=('TkDefaultFont', 10, 'bold')).grid(
            row=6, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        # Create sub-frame container for mapping files controls
        mapping_frame = ttk.Frame(main_frame)
        mapping_frame.grid(row=7, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Create button to add mapping files
        self.add_mapping_button = ttk.Button(mapping_frame, text="Add Mapping File", 
                  command=self.add_mapping_file, state='disabled')
        self.add_mapping_button.grid(row=0, column=0, sticky=tk.W)
        
        # Create listbox to display loaded mapping files
        self.mapping_listbox = tk.Listbox(mapping_frame, height=3)
        self.mapping_listbox.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 0))
        mapping_frame.columnconfigure(0, weight=1)
        
        # Create stage 2 process button with accent styling
        self.stage2_button = ttk.Button(main_frame, text="Process Stage 2 (Final Output with Mapping)", 
                  command=self.process_stage2, style='Accent.TButton', state='disabled')
        self.stage2_button.grid(row=8, column=0, columnspan=2, pady=10)
        
        # Create export configuration button
        self.config_export_button = ttk.Button(main_frame, text="Configure Export Options", 
                                              command=self.configure_export, state='disabled')
        self.config_export_button.grid(row=9, column=0, columnspan=2, pady=5)
        
        # Create export button initially disabled until data is processed
        self.export_button = ttk.Button(main_frame, text="Export Results", 
                                       command=self.export_data, state='disabled')
        self.export_button.grid(row=10, column=0, columnspan=2, pady=5)
        
        # Create StringVar to hold status messages for dynamic updates
        self.status_var = tk.StringVar(value="Ready to load file...")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, 
                              relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=11, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
    
    # Method to detect file encoding automatically
    def detect_encoding(self, file_path):
        """Detect the encoding of a file"""
        try:
            with open(file_path, 'rb') as f:
                raw_data = f.read(100000)
                result = chardet.detect(raw_data)
                encoding = result['encoding']
                return encoding if encoding else 'utf-8'
        except Exception:
            return 'utf-8'
    
    # Method to handle input file selection and loading
    def load_input_file(self):
        file_path = filedialog.askopenfilename(
            title="Select Input File",
            filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                # Detect file encoding automatically
                encoding = self.detect_encoding(file_path)
                
                if file_path.endswith('.csv'):
                    self.df = pd.read_csv(file_path, encoding=encoding)
                else:
                    self.df = pd.read_csv(file_path, delimiter='\t', encoding=encoding)
                
                self.input_file_path = file_path
                self.input_file_label.config(text=os.path.basename(file_path))
                
                # Clear field listbox
                self.field_listbox.delete(0, tk.END)
                for col in self.df.columns:
                    self.field_listbox.insert(tk.END, col)
                
                self.status_var.set(f"Loaded file with {len(self.df)} rows and {len(self.df.columns)} columns (encoding: {encoding})")
                
                # Enable field selection and stage 1 button
                self.stage1_button.config(state='normal')
                self.stage1_complete = False
                self.stage1_status_label.config(text="")
                self.add_mapping_button.config(state='disabled')
                self.stage2_button.config(state='disabled')
                self.config_export_button.config(state='disabled')
                self.export_button.config(state='disabled')
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load file: {str(e)}")
                self.status_var.set("Error loading file")
    
    # Method to perform stage 1 processing - dictionary expansion
    def process_stage1(self):
        if self.df is None:
            messagebox.showwarning("Warning", "Please load an input file first")
            return
        
        # Get user's field selections from the listbox
        selected_indices = self.field_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Warning", "Please select at least one field")
            return
        
        # Convert selection indices to field names
        self.selected_fields = [self.field_listbox.get(i) for i in selected_indices]
        
        try:
            # Detect dictionary fields only in selected fields
            self.dictionary_fields = self.detect_dictionary_fields(self.selected_fields)
            
            # Initialize dictionary to store user's key selections
            self.selected_keys = {}
            
            # If dictionary fields are found in selected fields, show popup for key selection
            if self.dictionary_fields:
                for field, available_keys in self.dictionary_fields.items():
                    if available_keys:
                        selected = self.show_key_selection_popup(field, available_keys)
                        if selected:
                            self.selected_keys[field] = selected
                        else:
                            # If user cancels, ask if they want to skip this field
                            response = messagebox.askyesno("Skip Field?", 
                                f"No keys selected for field '{field}'.\n\n"
                                f"Do you want to keep this field without dictionary expansion?")
                            if not response:
                                # Remove from selected fields if user doesn't want to keep it
                                self.selected_fields.remove(field)
            
            # Process stage 1 data
            self.stage1_data = self.process_stage1_dataframe()
            
            # Get column names from stage 1 data (only from selected fields processing)
            if self.stage1_data:
                stage1_columns = set()
                for row in self.stage1_data:
                    stage1_columns.update(row.keys())
                
                # Update the selected_fields to match stage 1 output columns
                self.selected_fields = list(stage1_columns)
            
            # Mark stage 1 as complete
            self.stage1_complete = True
            self.stage1_status_label.config(text=f"✓ Complete ({len(self.stage1_data)} rows)")
            
            # Enable mapping file addition and stage 2 processing
            self.add_mapping_button.config(state='normal')
            self.stage2_button.config(state='normal')
            
            self.status_var.set(f"Stage 1 complete. {len(self.stage1_data)} rows generated from selected fields. You can now add mapping files or proceed to Stage 2.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to process Stage 1: {str(e)}")
            self.status_var.set("Stage 1 processing failed")
    
    # Method to process dataframe for stage 1
    def process_stage1_dataframe(self):
        """Process the dataframe for stage 1 - dictionary expansion and multi-value splitting"""
        result_rows = []
        
        for index, row in self.df.iterrows():
            self.process_single_row(row, result_rows)
        
        return result_rows
    
    # Method to handle addition of mapping files
    def add_mapping_file(self):
        if not self.stage1_complete:
            messagebox.showwarning("Warning", "Please complete Stage 1 processing first")
            return
        
        file_path = filedialog.askopenfilename(
            title="Select Mapping File",
            filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                encoding = self.detect_encoding(file_path)
                
                if file_path.endswith('.csv'):
                    mapping_df = pd.read_csv(file_path, encoding=encoding)
                else:
                    mapping_df = pd.read_csv(file_path, delimiter='\t', encoding=encoding)
                
                # Get column names from stage 1 processed data
                if self.stage1_data:
                    stage1_columns = set()
                    for row in self.stage1_data:
                        stage1_columns.update(row.keys())
                else:
                    messagebox.showwarning("Warning", "No stage 1 data available")
                    return
                
                # Also check original input file columns
                original_columns = set(self.df.columns)
                
                input_fields = stage1_columns
                mapping_fields = set(mapping_df.columns)
                
                # First check stage 1 columns
                common_fields = input_fields.intersection(mapping_fields)
                
                # If not found in stage 1, check original input columns
                if not common_fields:
                    common_fields = original_columns.intersection(mapping_fields)
                    if common_fields:
                        # Store flag to indicate mapping key is from original file
                        mapping_source = "original"
                    else:
                        messagebox.showwarning("Warning", 
                            f"No matching columns found between stage 1 data/original file and mapping file.\n"
                            f"Stage 1 columns: {list(input_fields)}\n"
                            f"Original columns: {list(original_columns)}\n"
                            f"Mapping file columns: {list(mapping_fields)}")
                        return
                else:
                    mapping_source = "stage1"
                
                field_to_map = list(common_fields)[0]
                
                if len(common_fields) > 1:
                    field_to_map = simpledialog.askstring(
                        "Multiple Matches Found",
                        f"Multiple matching columns found: {list(common_fields)}\n"
                        f"Enter the field name to use for mapping:",
                        initialvalue=field_to_map
                    )
                    
                    if not field_to_map or field_to_map not in common_fields:
                        messagebox.showwarning("Warning", "Invalid field selection")
                        return
                
                self.mapping_files[field_to_map] = {
                    'path': file_path,
                    'source': mapping_source
                }
                self.mapping_data[field_to_map] = mapping_df
                
                source_text = "Stage 1 output" if mapping_source == "stage1" else "Original file"
                self.mapping_listbox.insert(tk.END, f"{field_to_map}: {os.path.basename(file_path)} (from {source_text})")
                
                self.status_var.set(f"Added mapping for field '{field_to_map}' (from {source_text})")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load mapping file: {str(e)}")
    
    # Method to split multi-valued strings
    def split_multi_values(self, value):
        """Split comma or semicolon separated values"""
        if pd.isna(value) or value == "" or value is None:
            return [""]
        
        # Convert to string to handle any data type
        value_str = str(value).strip()
        
        # Handle empty string after conversion
        if not value_str:
            return [""]
        
        if ';' in value_str:
            return [v.strip() for v in value_str.split(';') if v.strip()]
        elif ',' in value_str:
            return [v.strip() for v in value_str.split(',') if v.strip()]
        else:
            return [value_str]
    
    # Method to detect if a value contains dictionary-like data
    def is_dictionary_like(self, value):
        """Check if a value looks like a dictionary"""
        # Handle pandas NA, None, and empty values
        try:
            if pd.isna(value):
                return False
        except (ValueError, TypeError):
            # Handle cases where pd.isna raises an error (e.g., with arrays)
            if value is None:
                return False
        
        if value == "":
            return False
        
        value_str = str(value).strip()
        
        if value_str.startswith('{') and value_str.endswith('}'):
            return True
        
        if ':' in value_str or '=' in value_str:
            return True
        
        return False
    
    # Method to parse dictionary-like strings
    def parse_dictionary_value(self, value):
        """Parse dictionary-like value into key-value pairs, handling duplicate keys by collecting all values"""
        # Handle pandas NA, None, and empty values
        try:
            if pd.isna(value):
                return {}
        except (ValueError, TypeError):
            # Handle cases where pd.isna raises an error
            if value is None:
                return {}
        
        if value == "":
            return {}

        value_str = str(value).strip()
        result = {}

        # Try JSON parsing
        try:
            if value_str.startswith('{') and value_str.endswith('}'):
                parsed = json.loads(value_str)
                # Convert to list values to handle duplicates uniformly
                for k, v in parsed.items():
                    result[k] = [v] if not isinstance(v, list) else v
                return result
        except:
            pass

        # Try literal eval
        try:
            parsed = ast.literal_eval(value_str)
            if isinstance(parsed, dict):
                # Convert to list values to handle duplicates uniformly
                for k, v in parsed.items():
                    result[k] = [v] if not isinstance(v, list) else v
                return result
        except:
            pass

        # Manual parsing for newline-separated key-value pairs with duplicate key support
        try:
            lines = [line.strip() for line in value_str.split('\n') if line.strip()]

            for line in lines:
                if ':' in line:
                    key, val = line.split(':', 1)
                    key = key.strip()
                    val = val.strip()
                    # If key already exists, append to list; otherwise create new list
                    if key in result:
                        result[key].append(val)
                    else:
                        result[key] = [val]
                elif '=' in line:
                    key, val = line.split('=', 1)
                    key = key.strip()
                    val = val.strip()
                    # If key already exists, append to list; otherwise create new list
                    if key in result:
                        result[key].append(val)
                    else:
                        result[key] = [val]
                else:
                    # Store line as key with empty value
                    if line in result:
                        result[line].append("")
                    else:
                        result[line] = [""]

        except Exception:
            pass

        return result
    
    # Method to detect dictionary fields
    def detect_dictionary_fields(self, selected_fields):
        """Detect which fields contain dictionary-like values and collect all unique keys including duplicates"""
        dict_fields = {}
        
        for field in selected_fields:
            if field in self.df.columns:
                sample_values = self.df[field].dropna().head(10)
                
                dict_count = 0
                all_keys = set()
                
                for value in sample_values:
                    if self.is_dictionary_like(value):
                        dict_count += 1
                        parsed = self.parse_dictionary_value(value)
                        # Now parsed dict has lists as values, just get the keys
                        all_keys.update(parsed.keys())
                
                if dict_count > len(sample_values) * 0.5:
                    dict_fields[field] = list(all_keys)
        
        return dict_fields
    
    # Method to show key selection popup
    def show_key_selection_popup(self, field, available_keys):
        """Show popup for key selection in dictionary fields with manual selection (nothing pre-selected)"""
        # Create popup window as child of main window
        popup = tk.Toplevel(self.root)
        # Set popup title with field name
        popup.title(f"Select Keys for Field: {field}")
        # Set popup dimensions - larger for better visibility
        popup.geometry("450x350")
        # Make popup transient to main window (stays on top)
        popup.transient(self.root)
        # Make popup modal (blocks interaction with parent)
        popup.grab_set()
        
        # Header frame with title and instructions
        header_frame = ttk.Frame(popup)
        header_frame.pack(pady=10, padx=10, fill=tk.X)
        
        # Main instruction label with bold formatting
        ttk.Label(header_frame, text=f"Select keys to include from field '{field}':", 
                 font=('TkDefaultFont', 10, 'bold')).pack(anchor=tk.W)
        
        # Helpful tip for users about multi-selection
        ttk.Label(header_frame, text="Tip: Click on keys to select them. Hold Ctrl/Cmd to select multiple.", 
                 font=('TkDefaultFont', 8), foreground='gray').pack(anchor=tk.W, pady=(2, 0))
        
        # Key selection frame with listbox and scrollbar
        key_frame = ttk.Frame(popup)
        key_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Create listbox for multiple key selection
        key_listbox = tk.Listbox(key_frame, selectmode=tk.MULTIPLE)
        # Create scrollbar for the key listbox
        key_scrollbar = ttk.Scrollbar(key_frame, orient="vertical", command=key_listbox.yview)
        # Connect scrollbar to listbox
        key_listbox.configure(yscrollcommand=key_scrollbar.set)
        
        # Pack listbox to fill available space
        key_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        # Pack scrollbar on right side
        key_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Populate listbox with available keys from dictionary field
        for key in available_keys:
            key_listbox.insert(tk.END, key)
        
        # Status label to show real-time selection count
        status_label = ttk.Label(popup, text=f"0 of {len(available_keys)} keys selected", 
                                foreground='blue')
        status_label.pack(pady=(0, 5))
        
        # Function to update status label when selection changes
        def update_status(event=None):
            """Update the selection counter display"""
            count = len(key_listbox.curselection())
            status_label.config(text=f"{count} of {len(available_keys)} keys selected")
        
        # Bind listbox selection event to update function
        key_listbox.bind('<<ListboxSelect>>', update_status)
        
        # Initialize list to store user's key selections
        selected_keys = []
        
        # Function to select all keys at once
        def on_select_all():
            """Select all keys in the listbox"""
            key_listbox.select_set(0, tk.END)
            update_status()
        
        # Function to clear all selections
        def on_clear_all():
            """Clear all selections in the listbox"""
            key_listbox.selection_clear(0, tk.END)
            update_status()
        
        # Function to handle confirm button click
        def on_confirm():
            """Confirm selection and return selected keys"""
            # Access outer scope variable
            nonlocal selected_keys
            # Get indices of selected items
            selected_indices = key_listbox.curselection()
            # Convert indices to actual key names
            selected_keys = [available_keys[i] for i in selected_indices]
            # Close popup window
            popup.destroy()
        
        # Function to handle cancel button click
        def on_cancel():
            """Cancel selection and return empty list"""
            # Access outer scope variable
            nonlocal selected_keys
            # Clear selection list
            selected_keys = []
            # Close popup window
            popup.destroy()
        
        # Helper button frame for Select All and Clear All buttons
        helper_button_frame = ttk.Frame(popup)
        helper_button_frame.pack(pady=(5, 5))
        
        # Create "Select All" button for quick full selection
        ttk.Button(helper_button_frame, text="Select All", 
                  command=on_select_all).pack(side=tk.LEFT, padx=5)
        
        # Create "Clear All" button for quick deselection
        ttk.Button(helper_button_frame, text="Clear All", 
                  command=on_clear_all).pack(side=tk.LEFT, padx=5)
        
        # Main action button frame
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=10)
        
        # Create confirm button with descriptive label
        ttk.Button(button_frame, text="Confirm Selection", 
                  command=on_confirm).pack(side=tk.LEFT, padx=5)
        
        # Create cancel button
        ttk.Button(button_frame, text="Cancel", 
                  command=on_cancel).pack(side=tk.LEFT, padx=5)
        
        # Wait for popup window to be closed before continuing
        popup.wait_window()
        
        # Return user's key selections (empty list if cancelled or nothing selected)
        return selected_keys
    
    # Method to orchestrate stage 2 processing
    def process_stage2(self):
        """Stage 2: Apply mappings and generate final output"""
        if not self.stage1_complete or not self.stage1_data:
            messagebox.showwarning("Warning", "Please complete Stage 1 processing first")
            return
        
        try:
            # Apply mappings to stage 1 data
            if self.mapping_data:
                self.processed_data = self.apply_mappings(self.stage1_data.copy())
            else:
                self.processed_data = self.stage1_data.copy()
            
            self.config_export_button.config(state='normal')
            self.export_button.config(state='normal')
            self.status_var.set(f"Stage 2 complete. {len(self.processed_data)} rows ready for export.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to process Stage 2: {str(e)}")
            self.status_var.set("Stage 2 processing failed")
    
    # Method to process a single row
    def process_single_row(self, row, result_rows):
        """Process a single row, handling multi-values, dictionary fields with duplicate keys, and Cartesian product"""
        import itertools
        
        field_expansions = {}
        
        # Process regular fields
        for field in self.selected_fields:
            if field not in self.dictionary_fields:
                # Get the value, handling potential None/NA
                try:
                    field_value = row[field]
                except (KeyError, TypeError):
                    field_value = ""
                
                values = self.split_multi_values(field_value)
                unique_values = []
                for val in values:
                    if val and val not in unique_values:
                        unique_values.append(val)
                if not unique_values:
                    unique_values = [""]
                field_expansions[field] = unique_values
        
        # Process dictionary fields with duplicate key support
        for field in self.dictionary_fields:
            if field in self.selected_keys:
                # Get the dictionary field value
                try:
                    dict_value = row[field]
                except (KeyError, TypeError):
                    dict_value = ""
                
                parsed_dict = self.parse_dictionary_value(dict_value)
                
                for key in self.selected_keys[field]:
                    if key in parsed_dict:
                        # parsed_dict[key] is now a list of values (including duplicates)
                        all_key_values = []
                        for val in parsed_dict[key]:
                            # Handle None values in the list
                            if val is None:
                                val = ""
                            # Split each value for multi-values (comma/semicolon separated)
                            split_values = self.split_multi_values(val)
                            all_key_values.extend(split_values)
                        
                        # Remove duplicates while preserving order
                        unique_values = []
                        for val in all_key_values:
                            if val and val not in unique_values:
                                unique_values.append(val)
                        if not unique_values:
                            unique_values = [""]
                        field_expansions[f"{field}_{key}"] = unique_values
                    else:
                        field_expansions[f"{field}_{key}"] = [""]
        
        # Generate Cartesian product
        if field_expansions:
            field_names = list(field_expansions.keys())
            field_values = list(field_expansions.values())
            
            for combination in itertools.product(*field_values):
                new_row = {}
                for field_name, value in zip(field_names, combination):
                    new_row[field_name] = value
                
                if new_row not in result_rows:
                    result_rows.append(new_row)
    
    # Method to apply mappings
    def apply_mappings(self, result_rows):
        """Apply mapping files to add additional columns, keeping or excluding mapping key column based on source"""
        for field, mapping_df in self.mapping_data.items():
            mapping_info = self.mapping_files.get(field, {})
            mapping_source = mapping_info.get('source', 'stage1')
            
            if len(mapping_df.columns) >= 2:
                key_col = mapping_df.columns[0]
                value_col = mapping_df.columns[1]
                
                mapping_dict = dict(zip(mapping_df[key_col], mapping_df[value_col]))
                
                # If mapping key is from stage 1 output, keep it in final output
                if mapping_source == "stage1" and field in self.selected_fields:
                    for row in result_rows:
                        if field in row:
                            mapped_value = mapping_dict.get(row[field], "")
                            row[value_col] = mapped_value
                
                # If mapping key is from original file but not in stage 1 output
                else:
                    # Need to add mapping values by looking up from original data
                    for i, row in enumerate(result_rows):
                        # Get the corresponding original row
                        if i < len(self.df):
                            original_value = self.df.iloc[i].get(field, "")
                            mapped_value = mapping_dict.get(original_value, "")
                            row[value_col] = mapped_value
                            # Don't include the mapping key column in output
        
        return result_rows
    
    # Method to configure export options
    def configure_export(self):
        """Show dialog for configuring export options: renaming, sequencing, and default columns"""
        if not self.processed_data:
            messagebox.showwarning("Warning", "No processed data available")
            return
        
        # Create configuration popup
        config_popup = tk.Toplevel(self.root)
        config_popup.title("Configure Export Options")
        config_popup.geometry("700x600")
        config_popup.transient(self.root)
        config_popup.grab_set()
        
        # Create notebook for tabs
        notebook = ttk.Notebook(config_popup)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Tab 1: Column Renaming
        rename_frame = ttk.Frame(notebook)
        notebook.add(rename_frame, text="Rename Columns")
        
        ttk.Label(rename_frame, text="Rename columns (leave blank for original name or empty header):", 
                 font=('TkDefaultFont', 10, 'bold')).pack(pady=10, padx=10, anchor=tk.W)
        
        # Get current columns
        current_columns = list(self.processed_data[0].keys()) if self.processed_data else []
        
        # Create scrollable frame for rename entries
        rename_canvas = tk.Canvas(rename_frame)
        rename_scrollbar = ttk.Scrollbar(rename_frame, orient="vertical", command=rename_canvas.yview)
        rename_scrollable = ttk.Frame(rename_canvas)
        
        rename_scrollable.bind(
            "<Configure>",
            lambda e: rename_canvas.configure(scrollregion=rename_canvas.bbox("all"))
        )
        
        rename_canvas.create_window((0, 0), window=rename_scrollable, anchor="nw")
        rename_canvas.configure(yscrollcommand=rename_scrollbar.set)
        
        rename_entries = {}
        for i, col in enumerate(current_columns):
            frame = ttk.Frame(rename_scrollable)
            frame.pack(fill=tk.X, padx=10, pady=2)
            
            ttk.Label(frame, text=f"{col}:", width=30, anchor=tk.W).pack(side=tk.LEFT)
            entry = ttk.Entry(frame, width=30)
            entry.insert(0, self.column_rename_map.get(col, col))
            entry.pack(side=tk.LEFT, padx=5)
            rename_entries[col] = entry
        
        rename_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=10)
        rename_scrollbar.pack(side=tk.RIGHT, fill=tk.Y, pady=10, padx=(0, 10))
        
        # Tab 2: Column Sequence
        sequence_frame = ttk.Frame(notebook)
        notebook.add(sequence_frame, text="Column Sequence")
        
        ttk.Label(sequence_frame, text="Arrange column order (drag to reorder):", 
                 font=('TkDefaultFont', 10, 'bold')).pack(pady=10, padx=10, anchor=tk.W)
        
        # Create listbox for column sequencing
        seq_list_frame = ttk.Frame(sequence_frame)
        seq_list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        sequence_listbox = tk.Listbox(seq_list_frame, selectmode=tk.SINGLE)
        seq_scrollbar = ttk.Scrollbar(seq_list_frame, orient="vertical", command=sequence_listbox.yview)
        sequence_listbox.configure(yscrollcommand=seq_scrollbar.set)
        
        sequence_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        seq_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Populate with current sequence or default
        if self.column_sequence:
            for col in self.column_sequence:
                if col in current_columns:
                    sequence_listbox.insert(tk.END, col)
        else:
            for col in current_columns:
                sequence_listbox.insert(tk.END, col)
        
        # Buttons for moving columns
        seq_button_frame = ttk.Frame(sequence_frame)
        seq_button_frame.pack(pady=10)
        
        def move_up():
            selection = sequence_listbox.curselection()
            if selection and selection[0] > 0:
                idx = selection[0]
                item = sequence_listbox.get(idx)
                sequence_listbox.delete(idx)
                sequence_listbox.insert(idx - 1, item)
                sequence_listbox.select_set(idx - 1)
        
        def move_down():
            selection = sequence_listbox.curselection()
            if selection and selection[0] < sequence_listbox.size() - 1:
                idx = selection[0]
                item = sequence_listbox.get(idx)
                sequence_listbox.delete(idx)
                sequence_listbox.insert(idx + 1, item)
                sequence_listbox.select_set(idx + 1)
        
        ttk.Button(seq_button_frame, text="Move Up ↑", command=move_up).pack(side=tk.LEFT, padx=5)
        ttk.Button(seq_button_frame, text="Move Down ↓", command=move_down).pack(side=tk.LEFT, padx=5)
        
        # Tab 3: Default Columns
        default_frame = ttk.Frame(notebook)
        notebook.add(default_frame, text="Default Columns")
        
        ttk.Label(default_frame, text="Add default columns with values based on existing columns:", 
                 font=('TkDefaultFont', 10, 'bold')).pack(pady=10, padx=10, anchor=tk.W)
        
        # Create frame for default column entries
        default_canvas = tk.Canvas(default_frame)
        default_scrollbar = ttk.Scrollbar(default_frame, orient="vertical", command=default_canvas.yview)
        default_scrollable = ttk.Frame(default_canvas)
        
        default_scrollable.bind(
            "<Configure>",
            lambda e: default_canvas.configure(scrollregion=default_canvas.bbox("all"))
        )
        
        default_canvas.create_window((0, 0), window=default_scrollable, anchor="nw")
        default_canvas.configure(yscrollcommand=default_scrollbar.set)
        
        default_entries = []
        
        def add_default_column():
            frame = ttk.Frame(default_scrollable)
            frame.pack(fill=tk.X, padx=10, pady=5)
            
            ttk.Label(frame, text="New Column Name:", width=20).pack(side=tk.LEFT)
            name_entry = ttk.Entry(frame, width=20)
            name_entry.pack(side=tk.LEFT, padx=5)
            
            ttk.Label(frame, text="Based on Column:", width=15).pack(side=tk.LEFT, padx=(10, 0))
            based_on_combo = ttk.Combobox(frame, values=current_columns, width=20, state='readonly')
            based_on_combo.pack(side=tk.LEFT, padx=5)
            
            ttk.Label(frame, text="Value/Formula:", width=15).pack(side=tk.LEFT, padx=(10, 0))
            value_entry = ttk.Entry(frame, width=25)
            value_entry.pack(side=tk.LEFT, padx=5)
            
            def remove_entry():
                frame.destroy()
                default_entries.remove((name_entry, based_on_combo, value_entry))
            
            ttk.Button(frame, text="Remove", command=remove_entry).pack(side=tk.LEFT, padx=5)
            
            default_entries.append((name_entry, based_on_combo, value_entry))
        
        # Load existing default columns
        for col_name, col_info in self.default_columns.items():
            add_default_column()
            default_entries[-1][0].insert(0, col_name)
            default_entries[-1][1].set(col_info.get('based_on', ''))
            default_entries[-1][2].insert(0, col_info.get('value', ''))
        
        default_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(10, 0), pady=10)
        default_scrollbar.pack(side=tk.RIGHT, fill=tk.Y, pady=10, padx=(0, 10))
        
        ttk.Button(default_frame, text="Add Default Column", command=add_default_column).pack(pady=10)
        
        ttk.Label(default_frame, text="Tip: Use {column_value} in formula to reference the based-on column value", 
                 font=('TkDefaultFont', 8), foreground='gray').pack(pady=5)
        
        # Save button
        def save_configuration():
            # Save rename map
            self.column_rename_map = {}
            for orig_col, entry in rename_entries.items():
                new_name = entry.get().strip()
                if new_name != orig_col:  # Only store if different from original
                    self.column_rename_map[orig_col] = new_name
            
            # Save sequence
            self.column_sequence = []
            for i in range(sequence_listbox.size()):
                self.column_sequence.append(sequence_listbox.get(i))
            
            # Save default columns
            self.default_columns = {}
            for name_entry, based_combo, value_entry in default_entries:
                col_name = name_entry.get().strip()
                based_on = based_combo.get()
                value = value_entry.get().strip()
                
                if col_name and based_on:
                    self.default_columns[col_name] = {
                        'based_on': based_on,
                        'value': value
                    }
            
            messagebox.showinfo("Success", "Export configuration saved!")
            config_popup.destroy()
        
        button_frame = ttk.Frame(config_popup)
        button_frame.pack(pady=10)
        
        ttk.Button(button_frame, text="Save Configuration", command=save_configuration).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=config_popup.destroy).pack(side=tk.LEFT, padx=5)
    
    # Method to show completion popup
    def show_completion_popup(self):
        """Show popup asking user what to do next"""
        popup = tk.Toplevel(self.root)
        popup.title("Processing Complete")
        popup.geometry("300x150")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Data exported successfully!", 
                 font=('TkDefaultFont', 10, 'bold')).pack(pady=20)
        
        ttk.Label(popup, text="What would you like to do next?").pack(pady=5)
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=20)
        
        def continue_working():
            popup.destroy()
        
        def close_application():
            popup.destroy()
            self.root.destroy()
        
        ttk.Button(button_frame, text="Continue Working", 
                  command=continue_working).pack(side=tk.LEFT, padx=10)
        ttk.Button(button_frame, text="Close Application", 
                  command=close_application).pack(side=tk.LEFT, padx=10)
    
    # Method to export data
    def export_data(self):
        if not self.processed_data:
            messagebox.showwarning("Warning", "No processed data to export")
            return
        
        file_path = filedialog.asksaveasfilename(
            title="Save Processed Data",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                # Apply transformations
                export_data = self.apply_export_transformations(self.processed_data)
                
                df_export = pd.DataFrame(export_data)
                
                if file_path.endswith('.xlsx'):
                    df_export.to_excel(file_path, index=False)
                else:
                    df_export.to_csv(file_path, index=False)
                
                messagebox.showinfo("Success", f"Data exported successfully to {os.path.basename(file_path)}")
                self.status_var.set(f"Data exported to {os.path.basename(file_path)}")
                
                self.show_completion_popup()
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export data: {str(e)}")
    
    # Method to apply export transformations
    def apply_export_transformations(self, data):
        """Apply renaming, sequencing, and default columns to export data"""
        transformed_data = []
        
        for row in data:
            new_row = {}
            
            # First, add default columns
            for col_name, col_info in self.default_columns.items():
                based_on = col_info['based_on']
                value_template = col_info['value']
                
                if based_on in row:
                    based_value = row[based_on]
                    # Replace placeholder with actual value
                    if '{column_value}' in value_template:
                        new_value = value_template.replace('{column_value}', str(based_value))
                    else:
                        new_value = value_template
                    new_row[col_name] = new_value
                else:
                    new_row[col_name] = value_template
            
            # Add existing columns with renaming
            for orig_col, value in row.items():
                new_col_name = self.column_rename_map.get(orig_col, orig_col)
                new_row[new_col_name] = value
            
            transformed_data.append(new_row)
        
        # Apply column sequencing if specified
        if self.column_sequence:
            sequenced_data = []
            for row in transformed_data:
                sequenced_row = {}
                
                # First add columns in specified sequence
                for col in self.column_sequence:
                    # Check both original and renamed columns
                    if col in row:
                        sequenced_row[col] = row[col]
                    else:
                        # Check if this is a renamed column
                        for orig, renamed in self.column_rename_map.items():
                            if renamed == col and orig in row:
                                sequenced_row[col] = row[orig]
                                break
                
                # Then add any remaining columns not in sequence (including default columns)
                for col, value in row.items():
                    if col not in sequenced_row:
                        sequenced_row[col] = value
                
                sequenced_data.append(sequenced_row)
            
            return sequenced_data
        
        return transformed_data

# Main function
def main():
    root = tk.Tk()
    app = CSVProcessorGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()