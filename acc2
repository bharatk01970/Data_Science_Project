# Inside CSVProcessorGUI class

def choose_mapping_mode(self):
    """Show dialog: for each mapping field, let the user choose output type (direct or mapped)."""
    # Save: field â†’ mode chosen ('input' or 'mapping')
    field_modes = {}

    if not self.mapping_data:
        return {}

    popup = tk.Toplevel(self.root)
    popup.title("Select Mapping Usage Mode")
    popup.geometry("400x50" + str(70 * len(self.mapping_data)))
    popup.grab_set()

    ttk.Label(popup, text="Choose for each mapped field:").pack(pady=10)

    var_dict = {}
    for field in self.mapping_data:
        # Default: 'input'
        var = tk.StringVar(value="input")
        var_dict[field] = var
        frame = ttk.Frame(popup)
        frame.pack(anchor=tk.W, fill=tk.X, padx=10, pady=3)

        ttk.Label(frame, text=f"Field '{field}':").pack(side=tk.LEFT, padx=(0,8))
        ttk.Radiobutton(frame, text="Input Value", variable=var, value="input").pack(side=tk.LEFT)
        ttk.Radiobutton(frame, text="Mapped Value", variable=var, value="mapping").pack(side=tk.LEFT)

    def on_confirm():
        for field, var in var_dict.items():
            field_modes[field] = var.get()
        popup.destroy()

    ttk.Button(popup, text="Confirm", command=on_confirm).pack(pady=10)
    popup.wait_window()
    self.field_mapping_modes = field_modes

# Call this dialog inside process_stage2 before generating output
# Example placement in process_stage2 AFTER ensuring mappings & stage1_data:
def process_stage2(self):
    ...
    if self.mapping_data:
        self.choose_mapping_mode()
        # self.field_mapping_modes: dict, e.g.: {'Y': 'mapping', 'Z': 'input'}
    else:
        self.field_mapping_modes = {}
    self.processed_data = self.apply_mappings(self.stage1_data.copy())
    ...

# Major change in apply_mappings to honor user mode choice:
def apply_mappings(self, result_rows):
    """
    NEW: For each field with mapping, use input or mapped values per user choice
    """
    for field, mapping_df in self.mapping_data.items():
        mode = self.field_mapping_modes.get(field, "input")
        if len(mapping_df.columns) >= 2:
            key_col = mapping_df.columns[0]
            value_col = mapping_df.columns[1]
            mapping_dict = dict(zip(mapping_df[key_col], mapping_df[value_col]))

            for row in result_rows:
                if field in row:
                    if mode == "mapping":
                        mapped_value = mapping_dict.get(row[field], "")
                        row[field] = mapped_value  # replace original with mapped
                    # If mode == "input", leave row[field] unchanged
    return result_rows